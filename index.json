[{"categories":["java知识"],"content":"什么是消息队列？ 首先队列是先进先出，消息队列MQ可以简单理解成把要传输的数据放在队列中，主要解决应用耦合、异步消息、流量削锋等问题， 我认为大多数项目引入消息队列都是为了解决错峰流控和服务解耦这两主要问题。 错峰：线上部署的系统所面对的请求量会存在高峰和低谷，每天的23:00 - 8:00系统每秒接收的请求数为100，8:00 - 22:00系统每秒接收的请求数为3K+， 而到了22:00 - 23:00这个时间段，系统每秒接收的请求数为1W+。面对这种情况，我们不可能将系统的QPS(每秒查询)设计为1W+， 将MQ引入系统架构中，便解决了这种大流量冲击问题。假设将系统的QPS(每秒查询)设计为4K，满足了8:00 - 22:00的正常流量需求， 在22:00 - 23:00时间段里，可以先把所有的接收的请求放进MQ，系统仍然以4K的速度处理从MQ中请求，无法处理的积压在MQ中在23:00 - 8:00完成处理。 这样既防止了系统处理请求的速度始终没超过Max，也使系统在有限的资源情况下平稳的完成大流量请求。 流控：系统的上下游接口对同一请求的处理速度是不一致的，上游的A接口一秒处理完100个请求就会把100份数据直接丢给下游B接口， 而B接口的处理速度可能是一秒50个，这种情况下便会让B接口直接挂掉。此时，如果引入了MQ，可以让A接口处理完后直接写入MQ， 在让MQ以每秒50个的速度发送给下游B接口处理，协调了系统各接口通信能力。 服务解耦：以电商下单为例，下单步骤：用提交订单-\u003e预扣库存-\u003e生成订单-\u003e付款消费成功-\u003e通知配送系统-\u003e通知商家系统-\u003e通知后台系统计入财务、日志等模块这几个步骤。 当系统没有解耦时，顾客每个订单都是串行执行，需要等待时间太多，同时也浪费了接口的并发带来的性能提高。当引入消息队列对系统架构就行解耦， 用户可在订单系统生成订单后就直接返回，使用MQ后续同时处理剩余流程。既不影响整个业务的体验，而且在性能和响应速度上有了极大提升。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:1:0","tags":null,"title":"消息队列","uri":"https://hahaen.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["java知识"],"content":"如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？ 消息积压处理办法：临时紧急扩容： 先修复 consumer(肯修摸) 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。 新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue数量。 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理， 直接均匀轮询写入临时建立好的 10 倍数量的 queue。接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。 这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的consumer 机器来消费消息。 MQ 中消息失效：假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉， 这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。 我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了， 然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序， 一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理， 其中 1000个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。 mq 消息队列块满了：如果消息积压在 mq 里， 你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？ 没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。 然后走第二个方案，到了晚上再补数据吧。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/:2:0","tags":null,"title":"消息队列","uri":"https://hahaen.github.io/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"categories":["java知识"],"content":"什么是双亲委派模型? 如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成， 每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求时， 子加载器才会尝试去加载类。 当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载， 如果此时父类不能加载，反馈给子类，由子类去完成类的加载。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/:1:0","tags":null,"title":"双亲委派模型","uri":"https://hahaen.github.io/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"},{"categories":["java知识"],"content":"讲讲Elasticsearch是什么？原理?有什么用？如何使用？ ES是一个分布式、可扩展、实时的搜索与数据分析引擎。ES不仅仅只是全文搜索，还支持结构化搜索、数据分析、复杂的语言处理、地理位置和对象间关联关系等。 他底层依赖Lucene(路行)，然后可以在做一些搜索引擎，像电商网站的商品搜索、站内搜索、模糊查询、全文检索服务，还能做数据库做统计查询、日志分析。 主要原理就是先把搜索词分析，然后进行分词，在利用关键字搜索，然后再进行将搜索出来的结果排序。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/elasticsearch/:1:0","tags":null,"title":"Elasticsearch","uri":"https://hahaen.github.io/elasticsearch/"},{"categories":["前端"],"content":"Ajax原理 通过XmlHttpRequest对象来向服务器发送异步请求，从服务器获得数据，然后用JS来操作DOM而更新页面。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/ajax/:1:0","tags":null,"title":"Ajax","uri":"https://hahaen.github.io/ajax/"},{"categories":["java知识"],"content":"讲讲Servlet？ Java Servlet(谁为特) 是运行在 Web 服务器或应用服务器上的程序， 它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/servlet/:1:0","tags":null,"title":"Servlet","uri":"https://hahaen.github.io/servlet/"},{"categories":["运维"],"content":"Nginx为什么要做这个动静分离？ 因为我们网站要去优化，而他的重点就是在于我们要去静态化我们的网站嘛，然后我们网站静态化呢，它的关键点就是要把这个动静分离， 动静分离就是让我们这么一个动态网站里面的一些动态网页啊，根据一定的规则，把一些不变的资源，和经常变的资源区啊，区分开来， 那动静资源做好了拆分之后，我们就根据这些静态资源的特点啊，来去让他做一些缓存操作，让静态资源呢，只走静态资源的一个服务器， 动态资源走动态资源的一个服务器，nginx嘛，它的一个静态处理能力还是很强的，但是他动态处理能力是不足的， 所以经常，也是因为这个点，所以在项目中，经常使用这个动静分离技术，那对于这个静态资源呢， 比如说我们的图片啊，js、css啊，这些文件，我们都是在做反向代理服务器nginx中，去进行一个缓存， 这样的话我们浏览器，在请求某一个静态资源的时候呢，我们的代理服务器nginx，他就可以做一个直接的处理， 他就不需要去把我们这个请求，转发给我们的后端服务器，我们的tomcat，那如果我们的用户请求动态文件中呢， 比如说servlet、jsp啊，他去转发给tomcat的服务器处理啊，然后从而去实现我们的一个动静分离嘛。 这个也是我们反向代理服务器的一个重要的作用嘛。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/nginx/:1:0","tags":null,"title":"Nginx","uri":"https://hahaen.github.io/nginx/"},{"categories":["java知识"],"content":"Mybatis的xml,xml这个映射文件，和mybatis内部数据结构之间的这个映射关系是什么样的？ 这个映射关系，就是我们的Mybatis,他就是把我们的这个所有的xml的一个配置信息都封装到一个重量级对象里面， 这个重量级对象就是封装到我们的Configguration的内部，然后在我们的这个xml映射文件中呢， 我们的parameterMap呢，这个标签会被我们解析成我们的parameterMap对象，然后他这里的每一个子元素， 都会被我们解析，解析成我们的ParameterMapping对象，然后我们返回的结果级嘛，我们的嘛， 这个标签，会被我们解析成一个ResultMap一个对象，他这里面的每个子元素啊，都会被我们解析成ResultMapping一个对象， 所以他这些标签的话，就是每一个我们的增删改查嘛，我们的select、insert、update、delete这些标签呢， 都会被我们解析成我们的MappedStatement这么一个对象，然后我们标签内的这些sql,会被我们解析成BoundSql 的Sql对象。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/mybatis/:1:0","tags":null,"title":"Mybatis","uri":"https://hahaen.github.io/mybatis/"},{"categories":["java知识"],"content":"Mybatis是如何进行分页的？分页插件的原理是什么？ 这个是比较常用的一个功能，就是我们的Mybatis是使用我们的这个RowBounds对象去进行一个分页的， 他主要是针对我们的ResultSet一个结果级，去执行的一个内存分页，所以他这个其实不是一个物理分页， 这个可以在我们sql里面去直接写带有这个物理分页的参数，然后去完成我们的物理分页功能，也可以呢使用我们的一个分页插件， 这个也是比较常用的，来去实现我们的一个物理分页，那就是我们在用这个分页插件，他的基本原理， 其实就是使用我们Mybatis里面提供给我们的这些插件啊这些接口，然后去实现我们的一个自定义插件， 然后我们在这个插件的拦截方法内，去拦截我们这个待执行的sql语句嘛，那我们就重写sql语句， 然后根据像我们的一个dalect方言，也可以去添加这个对应的这些物理分页语句，和我们的物理分页的一些参数，这些原理就这样。 pageHelper ","date":"2022-08-21","objectID":"https://hahaen.github.io/mybatis/:2:0","tags":null,"title":"Mybatis","uri":"https://hahaen.github.io/mybatis/"},{"categories":["java知识"],"content":"mybatis和mybatis plus有啥区别？ MyBatis前身是iBatis，是java的持久层框架，可以使用XML或者注解进行映射和配置， 通过将参数映射到配置的SQL最终解析为执行的SQL语句，查询后将SQl结果集映射成java对象返回。 MyBatis-plus相当于是MyBatis的增强工具，例如内置 Sql 注入剥离器，预防了Sql注入攻击， 也支持代码生成，内置了分页插件、性能分析插件和全局拦截插件。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/mybatis/:3:0","tags":null,"title":"Mybatis","uri":"https://hahaen.github.io/mybatis/"},{"categories":["java知识"],"content":"mybatis是怎么和数据库交互的？ 通过dao层进入到mapper，然后用id去关联的。Resulttype(锐肉太不)是它所在的路径。还有用到resultMap。 如果是使用的mybatis-Plus，我们可以直接调save等方法，不用手写sql，会用plus封装好的方法直接查询数据。 当使用resultType做SQL语句返回结果类型处理时，对于SQL语句查询出的字段在相应的路径中必须有和它相同的字段对应， 而resultType中的内容就是在本项目中的位置。当使用resultMap做SQL语句返回结果类型处理时， 通常需要在mapper.xml中定义resultMap进行路径和相应表字段的对应。 常用的sql标签有test，if，choose，when等 ","date":"2022-08-21","objectID":"https://hahaen.github.io/mybatis/:4:0","tags":null,"title":"Mybatis","uri":"https://hahaen.github.io/mybatis/"},{"categories":["java知识"],"content":"#{}和${}的区别是什么？ ${}:是变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。 而#{}:是 sql 的参数占位符，MyBatis 会将 sql 中的#{}替换为?号，然后会将参数替换 另外使用 #{} 可以有效的防止SQL注入，提高系统安全性。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/mybatis/:5:0","tags":null,"title":"Mybatis","uri":"https://hahaen.github.io/mybatis/"},{"categories":["java知识"],"content":" jdbc:mysql://localhost:3306/wxshop ","date":"2022-08-21","objectID":"https://hahaen.github.io/jdbc/:0:0","tags":null,"title":"JDBC","uri":"https://hahaen.github.io/jdbc/"},{"categories":["java知识"],"content":"JDBC连接数据库步骤 注册数据库驱动 建立数据库连接 创建一个statement 执行SQL语句 处理结果集 关闭数据库连接 ","date":"2022-08-21","objectID":"https://hahaen.github.io/jdbc/:1:0","tags":null,"title":"JDBC","uri":"https://hahaen.github.io/jdbc/"},{"categories":["java知识"],"content":"你都了解java一些什么锁？ 锁的话比如说Synchronized，然后还有我们的ren，还有我们的ReentrantLock,读写锁了解的不多就没有研究了 ","date":"2022-08-21","objectID":"https://hahaen.github.io/java%E4%B8%AD%E7%9A%84%E9%94%81/:1:0","tags":null,"title":"Java中的锁","uri":"https://hahaen.github.io/java%E4%B8%AD%E7%9A%84%E9%94%81/"},{"categories":["java知识"],"content":"Synchronized的实现原理 Synchronized是我们JVM中实现的一种锁，然后这种锁，这种锁的一种获取啊，和它的释放方式啊， 分别都是我们的monitorenter，还有我们的monitorexit的一个指令， 那这个锁在实现上分为了我们的而偏向锁还有我们的轻量级锁，还有我们的重量级锁， 其中我们的偏向锁在1.6是默认开启的，然后轻量级锁呢是在我们的多线程竞争里面情况下， 他是会膨胀成重量级锁，也就是说有关于我们的这个锁的数据，他都会保存在我们的这个对象头中。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/java%E4%B8%AD%E7%9A%84%E9%94%81/:2:0","tags":null,"title":"Java中的锁","uri":"https://hahaen.github.io/java%E4%B8%AD%E7%9A%84%E9%94%81/"},{"categories":["java知识"],"content":"ReentrantLock的实现原理 ReentrantLock他是基于AQS实现的 ","date":"2022-08-21","objectID":"https://hahaen.github.io/java%E4%B8%AD%E7%9A%84%E9%94%81/:3:0","tags":null,"title":"Java中的锁","uri":"https://hahaen.github.io/java%E4%B8%AD%E7%9A%84%E9%94%81/"},{"categories":["java知识"],"content":"什么是AQS？ 就是在我们的AQS的内部中会保存一个变量state，一个状态变量state，然后通过CAS去修改这个变量值， 如果有修改成功的话，这个线程就会被表示我们获取到了这个锁， 如果没有修改成功的话就是或者说，我们发现这个state,已经是一个加锁状态， 那么就是通过一个waiter，这个对象封装线程，添加到等待队列里面，然后我们再把他给挂起啊，等待被唤醒。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/java%E4%B8%AD%E7%9A%84%E9%94%81/:4:0","tags":null,"title":"Java中的锁","uri":"https://hahaen.github.io/java%E4%B8%AD%E7%9A%84%E9%94%81/"},{"categories":["java知识"],"content":"CAS实现原理 CAS是通过unsafe类里面的compareAndSwap方法实现的。 那你知道这个方法里面的具体参数含义吗？ 这个看到有点久远了 他第一个参数是要修改的对象，第二个参数呢，是对象中要修改变量的这个偏移量，第三个参数呢就是我们修改之前的值，然后第四个参数是我们预想修改之后的值。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/java%E4%B8%AD%E7%9A%84%E9%94%81/:5:0","tags":null,"title":"Java中的锁","uri":"https://hahaen.github.io/java%E4%B8%AD%E7%9A%84%E9%94%81/"},{"categories":["JVM"],"content":"Volatile关键字 Volatile关键字，可以保证数据的一致性，可见性，但是不能解决原子性， 因为我们都是多核CPU嘛，多核CPU说白了就是一个线程把值改了， 其他线程可以马上感知到，在实现MESI协议的基础上， 他底层是用内存屏障，就是一个store和load指令，防止指令重排序，来达到一致性的目的， 但是他解决不了原子性，如果你想解决原子性的话一般我们通常的做法都是再去加把锁。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/volatile%E5%85%B3%E9%94%AE%E5%AD%97/:1:0","tags":null,"title":"Volatile关键字","uri":"https://hahaen.github.io/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["JVM"],"content":"JVM的内存模型 内存模型我大概记得有程序计数器，虚拟机栈，还有方法区，栈和堆， 然后栈是私有的，堆的话是多线程共享的， 他又分为年轻代和老年代，年轻代的话有伊甸dian园区，survivor0(色如why零)区，survivor1区， 一般的话我们通常给他设置成一个8:1:1的比例。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/jvm%E7%9F%A5%E8%AF%86/:1:0","tags":null,"title":"JVM知识","uri":"https://hahaen.github.io/jvm%E7%9F%A5%E8%AF%86/"},{"categories":["JVM"],"content":"JVM加载class文件的原理机制 JVM去加载我们class的原理机制的话，就是我们java中的一个所有类，都需要类加载器，装载到我们的JVM中才可以运行， 就是把我们文件从我们的硬盘啊，读取到我们的内存中， 所以我们在写程序的时候，其实我们几乎是不用关心这个类的加载， 因为这些都是隐式装载的，除非我们有些一些特殊的用法，想是我们的反射啊，就需要我们显示加载的所以需要的一个类， 那我们JVM中它的一个类的装载啊，是由我们类的加载器，就是我们的ClassLoader啊，我们ClassLoader和他的一个子类，去实现的， 是我们JVM中的一个类加载器，他是一个重要的java运行的一个系统组件啊，他就负责在我们运行是去查找和装入 ，我们的一个类文件中的一个类，由于我们Java中的一个跨平台性，所以经过一个编译的一个Java，它的一个原程序呢，并不是一个可知性的程序啊， 而是一个或者多个的一个类文件，所以在我们java程序中， 如果我们需要使用某个类的时候，JVM他会确保我们这个类啊，它的一个被加载了， 然后呢，我们的连接验证准备跟解析啊，然后最后到我们的初始化， 所以类的加载，是把我们类的class文件啊，中的一个数据呢，持续的把它读入到我们的内存中， 通常就是我们要创建一个节点嘛，数组嘛，然后去就是他的一个底层是创建一个节点数组，然后把他读入到我们的class文件中， 然后产生跟我们这个所加载的类相对应的一个class对象，差不多这样。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/jvm%E7%9F%A5%E8%AF%86/:2:0","tags":null,"title":"JVM知识","uri":"https://hahaen.github.io/jvm%E7%9F%A5%E8%AF%86/"},{"categories":["JVM"],"content":"java回收机制讲讲？ 使用Java的时候，会创建很多对象，但我们没手动将这些对象进行清除，如果用C/C++语言的时候，用完是需要自己释放掉， Java不用我们自己手动释放\"垃圾\"是因为JVM帮我们做了自动回收垃圾， 我个人对垃圾的定义：只要对象不再被使用了，那我们就认为该对象就是垃圾，对象所占用的空间就可以被回收。 判断对象不再被使用用的是 引用计数法 和 可达性分析法。 引用计数法:当对象被引用则+1，但对象引用失败则-1。当计数器为0时，说明对象不再被引用，可以被可回收,缺点是如果循环依赖，比如A依赖B,B依赖A,就无法判断是否被回收。 可达性分析法:从「GC Roots」开始向下搜索，当对象到「GC Roots」都没有任何引用相连时，说明对象是不可用的，可以被回收。 JVM用的就是「可达性分析算法」来判断对象是否垃圾。 垃圾回收的第一步就是「标记」，标记哪些没有被「GC Roots」引用的对象，标记完之后，我们就可以选择直接「清除」，只要不被「GC Roots」关联的，都可以干掉。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/jvm%E7%9F%A5%E8%AF%86/:3:0","tags":null,"title":"JVM知识","uri":"https://hahaen.github.io/jvm%E7%9F%A5%E8%AF%86/"},{"categories":["MySQL知识"],"content":"数据增删改查 ","date":"2022-08-21","objectID":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:0","tags":null,"title":"Mysql基础知识","uri":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["MySQL知识"],"content":"创建 USER表 PRIMARY KEY 主键 AUTO_INCREMENT AUTO_INCREMENT就可以从小到大自动生成 UNIQUE 约束唯一标识数据库表中的每条记录 ENGINE = InnoDB 存储引擎是innodb DEFAULT CHARSET = utf8mb4 修改字符集 COLLATE = utf8mb4_unicode_ci 排序的规则 CREATETABLEUSER(IDBIGINTPRIMARYKEYAUTO_INCREMENT,NAMEVARCHAR(100),TELVARCHAR(20)UNIQUE,AVATAR_URLVARCHAR(1024),ADDRESSVARCHAR(1024),CREATED_ATTIMESTAMPNOTNULLDEFAULTNOW(),UPDATED_ATTIMESTAMPNOTNULLDEFAULTNOW())ENGINE=InnoDBDEFAULTCHARSET=utf8mb4COLLATE=utf8mb4_unicode_ci; ","date":"2022-08-21","objectID":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:1","tags":null,"title":"Mysql基础知识","uri":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["MySQL知识"],"content":"增 INSERT[INTO]表名[(字段列表)]VALUES(值列表)[,(值列表),...]-- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ REPLACE与INSERT完全一样，可互换。INSERT[INTO]表名SET字段名=值[,字段名=值,...] 例子： insertintoperson(id,name,age,phone,address)values(1,'yang',22,'123232323','中国上海'); ","date":"2022-08-21","objectID":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:2","tags":null,"title":"Mysql基础知识","uri":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["MySQL知识"],"content":"删 DELETEFROM表名[删除条件子句]没有条件子句，则会删除全部 例子： deletefrompersonwhereid=1; ","date":"2022-08-21","objectID":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:3","tags":null,"title":"Mysql基础知识","uri":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["MySQL知识"],"content":"改 UPDATE表名SET字段名=新值[,字段名=新值][更新条件] 例子： updatepersonsetaddress='浙江杭州'; ","date":"2022-08-21","objectID":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:4","tags":null,"title":"Mysql基础知识","uri":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["MySQL知识"],"content":"查 SELECT字段列表FROM表名[其他子句]-- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段 例子： select*FROMperson; ","date":"2022-08-21","objectID":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:5","tags":null,"title":"Mysql基础知识","uri":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["MySQL知识"],"content":"Drop、delete区别？ 用法不同 drop(丢弃数据):drop table表名 ，直接将表都删除掉，在删除表的时候使用。 delete（删除数据）:delete from 表名 where 列名=值，删除某一列的数据 不带where子句的delete、以及drop都会删除表内的数据 但是delete只删除数据不删除表的结构(定义) 执行drop语句，此表的结构也会删除，也就是执行drop之后对应的表不复存在。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:0","tags":null,"title":"Mysql基础知识","uri":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["MySQL知识"],"content":"数据库主键和外键的区别 主键(主码) ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。 外键(外码) ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:0","tags":null,"title":"Mysql基础知识","uri":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["MySQL知识"],"content":"乐观锁和悲观锁的理解以及它的一下实现的一些方式？ 悲观锁顾名思义，我先一个个介绍，悲观锁就是很悲观，我们每次都在假设说我们在拿到这个数据的之前，有可能改过了我们这个数据，那就拿到不是我们想要的， 所以在每次拿到数据的之前的时候，他都会上一次锁，这样别人如果想要去改完们这个数据， 然后我们这个数据了他就会被阻塞到直到说他拿拿到这个锁，就我们传统的一些关系型数据库里面，其实用到很多， 像这种锁机制，比如说我们的行(hang)锁，我们的表锁,读锁啊写锁呀，都是在操作之前，要先给他上一个锁， 再比如我们Java的synchronized这个关键字，其实它的实现也是一个悲观锁，这是我对悲观锁的一个见解， 然后乐观锁，其实就是比较乐观，就是每次拿数据的时候呢，都觉得说别人不会在这个时候去改我们的数据，所以他不会去上一个锁， 那他不会上锁的话，但是我们在更新数据的时候，我们会去判断一下说这个期间内，别人有没有动过我们这个数据，有没有更新过我们这个数据， 所以乐观锁他可以提高我们的吞吐量，就像我们数据库里面他是有提供一个类，类似于我们的一个write_condition这么一个机制，其实就是提供一个乐观锁。 ","date":"2022-08-21","objectID":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:4:0","tags":null,"title":"Mysql基础知识","uri":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["MySQL知识"],"content":"事务 以及 MySQL数据结构 ","date":"2022-08-21","objectID":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:5:0","tags":null,"title":"Mysql基础知识","uri":"https://hahaen.github.io/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["工具教程"],"content":"docker安装Oracle数据库 docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g ","date":"2022-08-20","objectID":"https://hahaen.github.io/oracle-docker%E7%89%88%E6%95%99%E7%A8%8B/:1:0","tags":null,"title":"Oracle Docker版教程","uri":"https://hahaen.github.io/oracle-docker%E7%89%88%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"Docker创建数据库 docker run --name oracle_11g -d -p 1521:1521 registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g ","date":"2022-08-20","objectID":"https://hahaen.github.io/oracle-docker%E7%89%88%E6%95%99%E7%A8%8B/:2:0","tags":null,"title":"Oracle Docker版教程","uri":"https://hahaen.github.io/oracle-docker%E7%89%88%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"配置 进入容器里 docker exec -it oracle_11g bash 配置一下环境变量，执行su root后，输入密码 helowin(数据库名字) vi /etc/profile 并在文件最后添加如下命令 export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2export ORACLE_SID=helowinexport PATH=$ORACLE_HOME/bin:$PATH 使变量生效，接着切换为 oracle用户就可以正常使用了 source /etc/profileln -s $ORACLE_HOME/bin/sqlplus /usr/binsu - oracle 登录sqlplus并修改sys、system用户密码 sqlplus /nologconn /as sysdbaalter user system identified by oracle;alter user sys identified by oracle;ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED; exit退出 查看一下oracle实例状态 lsnrctl status 服务名要填写helowin(上面写的),账号:system,密码:oracle ","date":"2022-08-20","objectID":"https://hahaen.github.io/oracle-docker%E7%89%88%E6%95%99%E7%A8%8B/:3:0","tags":null,"title":"Oracle Docker版教程","uri":"https://hahaen.github.io/oracle-docker%E7%89%88%E6%95%99%E7%A8%8B/"},{"categories":["java知识"],"content":"Java面向对象三大特性封装继承多态 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:1:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"封装 封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的⽅法 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:1:1","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"继承 继承是使⽤已存在的类的定义作为基础建⽴新类的技术，新类的定义可以增加新的数据或新的功能, 也可以⽤⽗类的功能，但不能选择性地继承⽗类。通过使⽤继承我们能够⾮常⽅便地复⽤以前的代码。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:1:2","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"多态 指父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作作用于不同对象，可以有不同的解释，产生不同的执行结果。 继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖接⼝中同⼀⽅法）。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:1:3","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"Java的基本类型 基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型： 整数类型：byte，short，int，long 浮点数类型：float，double 字符类型：char 布尔类型：boolean String是基本数据类型吗？答：不是 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:2:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"String中有哪些方法？ 常用方法： indexOf() 返回指定字符的索引。 charAt() 返回指定索引处的字符。 replace() 字符串替换。 trim() 去除字符串两端空白。 split() 分割字符串，返回一个分割后的字符串数组。 getBytes() 返回字符串的 byte 类型数组。 length() 返回字符串长度。 toLowerCase() 将字符串转成小写字母。 toUpperCase() 将字符串转成大写字符。 substring() 截取字符串。 equals() 字符串比较。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:3:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"Object有哪些方法？ Object类，属于java.lang包，位于类层次结构树的顶部。 每个类都是Object类的直接或间接的后代。 使用或编写的每个类都继承Object的实例方法。 常用方法： getClass 方法 final 方法、获取对象的运行时 class 对象，class 对象就是描述对象所属类的对象。 hashCode 方法 该方法主要用于获取对象的散列值。Object 中该方法默认返回的是对象的堆内存地址。 equals 方法 该方法用于比较两个对象，如果这两个对象引用指向的是同一个对象，那么返回 true，否则返回 false。 clone 方法 该方法是保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常。 toString 方法 返回一个 String 对象，一般子类都有覆盖。默认返回格式如下：对象的 class 名称 + @ + hashCode 的十六进制字符串。 wait 方法 当timeout 为 0，即不等待。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:4:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"==、Equals区别？ 对象类型不同 equals()：是超类Object中的方法。 ==：是操作符。 比较的对象不同 equals()：用来检测两个对象是否相等，即两个对象的内容是否相等。 ==：用于比较引用和比较基本数据类型时具有不同的功能 运行速度不同 equals()：没有==运行速度快。 ==：运行速度比equals()快，因为==只是比较引用。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:5:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"为什么重写equals时必须重写hashCode方法？ 因为两个相等的对象的hashCode值必须是相等。 也就是说如果equals方法判断两个对象是相等的，那这两个对象的hashCode值也要相等。 如果重写equals()时没有重写hashCode()方法的话就可能会导致equals方法判断是相等的两个对象,hashCode值却不相等。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:6:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"Final的作用？ 在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。 修饰类 当用final修饰一个类时，表明这个类不能被继承。 修饰方法 如果只有在想明确禁止,该方法在子类中被覆盖的情况下才将方法设置为final的。 即父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的。 修饰变量 final成员变量表示常量，只能被赋值一次，赋值后值不再改变。 当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化； 如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。 final修饰一个成员变量（属性），必须要显示初始化。 当函数的参数类型声明为final时，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:7:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"StringBuffer、StringBuilder区别? StringBuffer稍慢，但线程安全 StringBuilder更快，但线程不安全，常用 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:8:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"抽象类和接口的区别 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:9:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"面向对象和面向过程的区别？ 首先我们面向过程的话，是我们去分析解决问题的一个步骤，然后用我们的函数，把这些步骤一步一步的实现， 然后我们在使用的时候，其实只要一一调用就可以，性能会比较高， 所以是咱们的单片机或者是嵌入式开发，一般都会用这个面向过程去开发。 而面向对象呢，这边的话是把我们构成问题的这些事物，分解成各个对象，就是其实也是万物皆对象， 那我们在建立这个对象的目的呢，其实也不是为了说完成一个个步骤，而是我们在描述某个事物， 然后再解决整个问题过程中发生的一些行为，所以我们面向对象，他们会有一些封装、继承、多态的一些特性， 所以他会比较容易维护，然后也会比较好复用比较好拓展，就是可以设计出一个我们的一个低耦合的一个系统， 但是性能上来说的话会比我们这个面向过程的话，会比要来的低，差不多是这样。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:10:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"线程、程序、进程的基本概念，以及他们之间是一个怎么样的关系。 线程其实跟我们的进程会有点相似，但是线程呢，他其实是一个比我们这个进程哦， 还要更小一点的一个执行单位，一个进程呢，在我们执行的时候的过程中，他会产生一个或多个的一个线程， 所以与我们这个进程不同的是，就是我们在同类的这个多线程，他共享同一块这个内存空间，和我们的一组这个系统资源， 所以这个系统呢，他也会产生一个线程或者说在各个线程之间呢，切换工作时，它的一个负担，会比我们这个进程要小的多， 也正是因为如此，所以线程他其实也会被称为一个轻量级的一个进程。那我们程序的话，其实就是指说，我们的含有指令的，和我们这个数据的这些文件， 那这些文件呢，是被存储在磁盘或者说其他数据呢，的一个存储设备中，也就是说我们这个，其实他更像一个静态的一个代码， 那我们进程就是我们程序，它的一次执行过程中呢，他是这个系统运行程序的一个最基本的一个单位，也正是因为如此， 所以这个进程其实他是一个动态的，就是我们系统如果运行一个程序的话，那就是一个进程，从我们的这个创建啊，然后到我们运行啊， 再到我们的消亡啊，这么一个过程，所以简单来说的话，这个一个进程其实就是一个执行中的一个程序， 他在计算机中的一个指令啊，就是一个指令接着一个指令去执行着，然后同时呢，每个进程呢，他还会占有这个某些系统资源的， 比如说我们的这个CPU的时间，内存空间啊，我们的文件啊，还有我们的输入输出设备的这些使用权啊，所以其实就是这个程序在执行的时候， 他都会被我们这个操作系统啊，载入到我们这个内存中，然后呢我们这个线程呢，他是进程里面划分的一个更小的一个运行单位， 所以线程和进程他有一个最大的不同就是在于，基本上这个每个进程都是一个独立的，但是每个线程就不一定了， 因为同一个进程中里面的这些线程，他们是非常有可能会影响到的，就是我们从另一个角度上来说的话，这个进程呢，他属于操纵系统的范畴， 然后如果主要是同一时间段内啊，然后我们可以同时执行一个或以上的一个程序， 然后这个线程呢，就是在我们同一程序内，几乎是同时执行一个以上的一个程序段，差不多是这样。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:11:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"深拷贝和浅拷贝的区别？ 如果是浅拷贝的话，就是我们被复制的对象，这里面所有的变量，大多含与我们这个原来的对象，会有相同的值， 然后所有的，对其他的一个引用呢，他热然是指向我们这个原来的这些对象， 其实简单说的话就是浅拷贝，他仅仅复制了我们所考虑的对象，而不是复制了他所引用的对象。 那如果是我们的深拷贝的话，就是他被复制对象的这些所有变量啊，都是含有跟原来的这个对象相同的值， 那些被引用其他对象的变量呢，就会将指向我们这个被复制的这个新对象，而不是原有的那些被引用的这么一个对象， 其实简单说的话就是我们的一个，深拷贝就是把我们这个复制的对象，所引用的对象呢，都复制了一遍，差不多就是这样。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:12:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"Cookie和Session的区别？ 那我们首先就先说一下这个Cookie嘛，Cookie这边，是以这个客户端浏览器用来保存我们数据的一种机制， 好那就是当我们通过这个浏览器去进行我们这个网页访问的时候呢，服务器这边可以把我们某些数据，以这个key-value啊，就是我们那个键值对嘛， 以这种方式写入到我们的Cookie里面，然后存储到我们这个客服端的浏览器， 然后我们客服端下一次再去访问这个服务器的时候，就可以携带这些状态数据，发送到我们的服务器端， 然后我们服务器端里面，这边就可以根据我们的Cookie，Cookie里面携带的内容，去识别我们这个，具体是哪位客户的一个使用者。 那如果是我们的Session的话，就是我们的一个会话，他是属于我们服务端的一个容器对象， 那么在默认情况下啊，就是默认情况下我们这个Session，他会针对我们每个浏览器的一个请求，就是我们的这个Servlet的这个容器， 他都会分配一个Session，我们Session其实他本质上是一个我们的一个ConcurrentHashMap，然后可以存储到我们当前会话，产生的一些状态数据， 嗯，因为我们的这个HTTP协议啊，他本省其实是一个无状态的一个协议，那这种无状态协议也就是说我们服务器他，并不会去知道我们的客户端， 发送过来的一个多次请求，是不是属于同一个用户的，所以我们Session就是来弥补这个HTTP，这个无状态的一个不足嘛，就是我们这个服务器端， 他可以用我们的Session去存储我们的客户端在同一个会话里面的一个多次的一个请求记录，然后，基于我们这个服务端的Session的这些储存机制的话， 在结合我们客服端的这个Cookie机制，然后就可以实现我们这个有状态的一个HTTP协议了，总的来看的话，其实Cookie就是我们这个客服端的一个存储机制， 然后Session是我们服务端的一个存储机制，这两者去结合使用，来去实现我们一个规划的存储。以上是我这个问题的理解。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:13:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"token token类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:14:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"重载和重写有什么区别？ 重载的话都是在一个类里面的，就是方法名相同的，然后这里面呢，是他们都可能说是参数不同，返回类型也是可以不同的， 那每个重载的方法，或者说这个构造函数，构造函数也是有这个的，都会有一个独一无二的一个参数， 类型的一个列表，那这个最常用的就是我们这个构造器的重载， 比如说我们的有参构造啊，我们的无参构造啊，这些都是最常用的，或者说不同参数的这些构造方法。 重写的话呢，是发生在这个面向对象里面的那个继承，就是发生在我们的父类和子类之间，方法名相同，然后它的一个参数列表也是相同的， 返回值的这个范围就是小于等于我们的父类，然后抛出异常的这个范围，也是小于等于我们的父类，然后他这边的话，就是访问我们的修饰符的范围， 是大于等于我们的父类的，如果我们父类这个方法啊，如果我们父类方法修饰符为private,就是私有化，那么子类就不能重新我们这个方法， 因为他都不能继承到这个方法。然后这边的话，我们的重载和重写都是多态的一种体现，的一种方式嘛，就是我们重载是编译期间的一个活动， 然后重写是我们这个运行期间的一个活动，然后就是我们这个重载是在一个类中定义的这个相同名字和方法，然后就是这个方法的参数列表和类型都要不同， 然后返回型也可以不同，是我们一个重写的标准，然后也可以修改为可见性，然后重写是不一样的，他要求我们这个子类去重写这个基类的方法时候， 要跟父类方法具有相样的，就是基本上都要一样，那他的一个可见性是需要大于等于我们这个基类的一个方法，差不多就是这样。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:15:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"IO流一般分为几种？ 如果是按照功能来分的话，一个就是我们的输入流（input），还有就是我们的输出流（output）嘛， 然后如果是按类型来分的话，就是也有分我们的子节流啊，和我们的字符流，那子节流和我们的字符流他们也有一些区别嘛， 子节流他是按照我们的一个8位传输，是以字节为单位的，这么一个输入输出的我们的数据，然后我们的字符流，是以16位的， 然后是以字符为单位的，去输入输出我们的这些数据。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:16:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"静态变量和普通变量这一块的区别？ 静态变量的话就是我们static的变量嘛，他们的区别就是说静态变量他这是我们所有的一个对象是共享的， 因为我们在项目运行的时候，他在内存中就只有一个副本，想这个副本的话， 就是说我们在程序初次加载的时候，会被初始化嘛，然后普通变量是在我们对象里面的，他是对象里面所拥有的，就是我们在创建对象的时候，会被初始化， 然后呢他就会有很多的副本，因为我们可能这边new一个对象那边new一个对象，他就存在很多个这个普通的一个变量， 但是这个各个对象之间，他们存在多个副本的话，就各个对象里面这个副本，他们也是互相不会影响的， 然后还有一点就是说我们的static我们的这个静态变量，它的一个初始化顺序，是按照我们定义的这个顺序去进行初始化的，就这些，这就是他们的区别。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:17:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"自增运算符++和自减运算符 ++ 和 – 运算符可以放在变量之前，也可以放在变量之后 当运算符放在变量之前时(前缀)，先自增/减，再赋值 ++a 当运算符放在变量之后时(后缀)，先赋值，再自增/减 a-- 例如 当 b = ++a 时，先自增（自己增加 1），再赋值（赋值给 b） 当 b = a++ 时，先赋值(赋值给 b)，再自增（自己增加 1） ++a 输出的是 a+1 的值，a++输出的是 a 值 “符号在前就先加/减，符号在后就后加/减” ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:18:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"Java的参数传递是传值还是传引用？ Java世界中的一切对象都是指针(地址) 函数调用永远是传值 基本类型（包括String类）作为参数传递时，是传递值的拷贝，无论你怎么改变这个拷贝，原值是不会改变的 引用类型（包括数组，对象以及接口）作为参数传递时，是把对象在内存中的地址拷贝了一份传给了参数。 注意：基本数据类型的封装类Integer、Short、Float、Double、Long、Boolean、Byte、Character虽然是引用类型， 但它们在作为参数传递时，也和基本数据类型一样，是值传递。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:19:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"Continue、break和return的区别是什么？ 在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。 但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环， 这就需要用到下面几个关键词： continue：指跳出当前的这一次循环，继续下一次循环。 break：指跳出整个循环体，继续执行循环下面的语句。 return：用于跳出所在方法，结束该方法的运行。return 一般有两种用法： return; ：直接使用 return 结束方法执行，用于没有返回值函数的方法 return value; ：return 一个特定值，用于有返回值函数的方法 下列语句的运行结果是什么？ public static void main(String[] args) { boolean flag = false; for (int i = 0; i \u003c= 3; i++) { if (i == 0) { System.out.println(\"0\"); } else if (i == 1) { System.out.println(\"1\"); continue; } else if (i == 2) { System.out.println(\"2\"); flag = true; } else if (i == 3) { System.out.println(\"3\"); break; } else if (i == 4) { System.out.println(\"4\"); } System.out.println(\"xixi\"); } if (flag) { System.out.println(\"haha\"); return; } System.out.println(\"heihei\"); } 运行结果: 0 xixi 1 2 xixi 3 haha ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:20:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"Java异常 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:21:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"异常基本类型 异常类的基本类型是Throwable类 两大子类分别是Error和Exception Error 系统错误由Java虚拟机抛出，用Error类表示。Error类描述的是内部系统错误 例如：Java虚拟机崩溃。在程序中不会对Error异常进行捕捉和抛出。 Exception 异常Exception又分为RuntimeException(运行时异常)和CheckedException(检查时异常) RuntimeException(运行时异常) 程序运行过程中才可能发生的异常,一般为代码的逻辑错误 例如：类型错误转换，空指针异常、找不到指定类等 CheckedException(检查时异常) 编译期间可以检查到的异常，必须显式的进行处理（捕获或者抛出到上一层） 例如：IOException, FileNotFoundException,SQLException等 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:21:1","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"异常处理 throws（声明异常） 在方法头中显式声明该异常，以便于告知方法调用者此方法有异常 若父类的方法没有声明异常，则子类继承方法后，也不能声明异常 try-catch（捕获异常） 若执行try块的过程中没有发生异常，则跳过catch子句 若是出现异常，try块中剩余语句不再执行。 再判断catch块的异常类是否是捕获的异常类型，匹配后执行相应的catch块中的代码。 如果有finally的话进入到finally里面继续执行。 try ctach fianally中有return时，会先执行return,但是不会返回。在执行完finally后进行返回 catch语句可以有一个或多个，finally语句最多一个 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:21:2","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"throw,throws关键字区别 throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常 throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常 public static void test()throws Exception{ throw new Exception(\"方法test中的Exception\"); } ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:22:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"常见的几种异常 RuntimeExceptionjava.lang.ArithmeticException(算术异常) java.lang.NullPointerException(空指针异常) java.lang.ClassCastException(类型转换异常) java.lang.IllegalArgumentException(不合法的参数异常) java.lang.IndexOutOfBoundsException(数组下标越界异常) java.io.IOException(IO流异常) java.lang.ClassNotFoundException(没找到指定类异常) java.lang.NoSuchFieldException(没找到指定字段异常) java.lang.NoSuchMetodException(没找到指定方法异常) java.lang.IllegalAccessException(非法访问异常) java.lang.InterruptedException(中断异常) ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:23:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"静态方法为什么不能调用非静态方法？ 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。 在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:24:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"静态方法和实例方法有何不同？ ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:25:0","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"调用方式 在外部调用静态方法时，可以使用类名.方法名的方式，也可以使用对象.方法名的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 不过，需要注意的是一般不建议使用对象.方法名的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。 因此，一般建议使用类名.方法名的方式来调用静态方法。 public class Person { public void method() { //...... } public static void staicMethod(){ //...... } public static void main(String[] args) { Person person = new Person(); // 调用实例方法 person.method(); // 调用静态方法 Person.staicMethod() } } ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:25:1","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["java知识"],"content":"访问类成员是否存在限制 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。 ","date":"2022-08-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:25:2","tags":null,"title":"java基础知识整理","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["工具教程"],"content":"docker搭建minio单节点 拉取docker镜像 docker pull minio/minio 创建挂载文件夹 mkdir -p /root/minio/config /root/minio/data 启动容器 docker run -p 9000:9000 -p 1314:9001 --name minio --restart=always -e \"MINIO_ACCESS_KEY=xxxxxx\" -e \"MINIO_SECRET_KEY=xxxxxxxx\" -v /root/minio/data:/data -v /root/minio/config:/root/.minio -d minio/minio server /data --console-address \":9001\" 注意： MINIO_ACCESS_KEY（用户名） MINIO_SECRET_KEY（密码，最少8位） 它需要两个端口，9000为客户端连接端口，1314为Web管理端口 密码不安全报错 ERROR Unable to validate credentials inherited from the shell environment: Invalid credentials \u003e Please provide correct credentials HINT: Access key length should be at least 3, and secret key length at least 8 characters ","date":"2022-06-17","objectID":"https://hahaen.github.io/minio/:1:0","tags":null,"title":"Minio","uri":"https://hahaen.github.io/minio/"},{"categories":["java知识"],"content":"java常用设计模式 ","date":"2022-06-12","objectID":"https://hahaen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Foverview/:1:0","tags":null,"title":"设计模式（Overview）","uri":"https://hahaen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Foverview/"},{"categories":["java知识"],"content":"Spring中使用到了哪些设计模式？ ","date":"2022-06-12","objectID":"https://hahaen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Foverview/:2:0","tags":null,"title":"设计模式（Overview）","uri":"https://hahaen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Foverview/"},{"categories":["java知识"],"content":"24大设计模式和7个原则 ","date":"2022-06-12","objectID":"https://hahaen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Foverview/:3:0","tags":null,"title":"设计模式（Overview）","uri":"https://hahaen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Foverview/"},{"categories":["java知识"],"content":"7个原则 1. 单一职责原则 一个类负责一项职责。 2. 开放封闭原则 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 3. 里氏替换原则 继承与派生的规则。 4. 依赖倒置原则 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。 5. 接口隔离原则 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。 6. 迪米特法则 低耦合，高内聚。 7. 组合/聚合复用原则 尽量使用组合和聚合少使用继承的关系来达到复用的原则。 ","date":"2022-06-12","objectID":"https://hahaen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Foverview/:3:1","tags":null,"title":"设计模式（Overview）","uri":"https://hahaen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Foverview/"},{"categories":["java知识"],"content":"24大设计模式 创建型 - 单例模式 确保一个类只有一个实例，并提供该实例的全局访问点 创建型 - 简单工厂 它把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化，这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类 创建型 - 工厂方法 它定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类 创建型 - 抽象工厂 抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同 创建型 - 生成器 封装一个对象的构造过程，并允许按步骤构造 创建型 - 原型模式 使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象 结构型 - 外观 它提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用 结构型 - 适配器 将一个类的接口, 转换成客户期望的另一个接口。 适配器让原本接口不兼容的类可以合作无间。 对象适配器使用组合, 类适配器使用多重继承 结构型 - 桥接 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变 结构型 - 组合 允许你将对象组合成树形结构来表现\"整体/部分\"层次结构. 组合能让客户以一致的方式处理个别对象以及对象组合 结构型 - 装饰 动态地将责任附加到对象上, 若要扩展功能, 装饰者提供了比继承更有弹性的替代方案 结构型 - 享元 利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。 它让某个类的一个实例能用来提供许多\"虚拟实例\" 结构型 - 代理 为另一个对象提供一个替身或占位符以控制对这个对象的访问 行为型 - 责任链 通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象 行为型 - 策略 定义了算法族, 分别封闭起来, 让它们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户 行为型 - 模板方法 在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤 行为型 - 命令模式 将\"请求\"封闭成对象, 以便使用不同的请求,队列或者日志来参数化其他对象. 命令模式也支持可撤销的操作 行为型 - 观察者 在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新 行为型 - 访问者 当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式 行为型 - 状态 允许对象在内部状态改变时改变它的行为, 对象看起来好象改了它的类 行为型 - 解释器 使用解释器模式为语言创建解释器，通常由语言的语法和语法分析来定义 行为型 - 迭代器 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露其内部的表示 行为型 - 中介者 使用中介者模式来集中相关对象之间复杂的沟通和控制方式 行为型 - 备忘录 当你需要让对象返回之前的状态时(例如, 你的用户请求\"撤销\"), 你使用备忘录模式 知识体系图 ","date":"2022-06-12","objectID":"https://hahaen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Foverview/:3:2","tags":null,"title":"设计模式（Overview）","uri":"https://hahaen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Foverview/"},{"categories":["java知识"],"content":"参考 设计模式六大原则 http://www.uml.org.cn/sjms/201211023.asp 设计模式原则详解 https://developer.aliyun.com/article/940284 一张图24种设计模式\u00267种设计原则 https://www.jianshu.com/p/6ee99cf66e4d 真正的深入浅出“设计模式” - 最易懂的设计模式解析 https://www.jianshu.com/p/6e5eda3a51af Java设计模式Gitbook https://gof.quanke.name/ Java设计模式源码 https://github.com/quanke/design-pattern-java-source-code ","date":"2022-06-12","objectID":"https://hahaen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Foverview/:4:0","tags":null,"title":"设计模式（Overview）","uri":"https://hahaen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Foverview/"},{"categories":["笔记"],"content":"内容 ","date":"2022-05-30","objectID":"https://hahaen.github.io/java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C-%E9%BB%84%E5%B1%B1%E7%89%88%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"Java开发手册 黄山版（笔记）","uri":"https://hahaen.github.io/java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C-%E9%BB%84%E5%B1%B1%E7%89%88%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"内容 ","date":"2022-05-30","objectID":"https://hahaen.github.io/effective-java%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"effective-java中文（笔记）","uri":"https://hahaen.github.io/effective-java%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"内容 ","date":"2022-05-30","objectID":"https://hahaen.github.io/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"MySQL必知必会（笔记）","uri":"https://hahaen.github.io/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%94%E8%AE%B0/"},{"categories":["各种问题"],"content":"双击bin目录下的idea.bat 报错 ERROR - llij.ide.plugins.PluginManager - java.net.BindException: Address already in use: bind 参考 运行两个命令成功解决。 net stop winnat net start winnat ","date":"2022-05-29","objectID":"https://hahaen.github.io/idea%E5%90%AF%E5%8A%A8%E5%BC%82%E5%B8%B8/:1:0","tags":null,"title":"Idea启动异常","uri":"https://hahaen.github.io/idea%E5%90%AF%E5%8A%A8%E5%BC%82%E5%B8%B8/"},{"categories":["各种问题"],"content":"插件备份 ","date":"2022-05-20","objectID":"https://hahaen.github.io/idea%E8%87%AA%E7%94%A8%E6%8F%92%E4%BB%B6%E8%AE%B0%E5%BD%95/:1:0","tags":null,"title":"Idea自用插件记录","uri":"https://hahaen.github.io/idea%E8%87%AA%E7%94%A8%E6%8F%92%E4%BB%B6%E8%AE%B0%E5%BD%95/"},{"categories":["java知识"],"content":"集合 ","date":"2022-05-16","objectID":"https://hahaen.github.io/%E9%9B%86%E5%90%88/:0:0","tags":null,"title":"集合","uri":"https://hahaen.github.io/%E9%9B%86%E5%90%88/"},{"categories":["java知识"],"content":"常见的集合有哪些？ Java集合类主要由两个根接口Collection和Map派生出来的 Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列） 因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。 注意： Collection是一个接口，Collections是一个工具类，Map不是Collection的子接口。 Collection体系简介图 List代表了有序可重复集合，可直接根据元素的索引来访问 Set代表无序不可重复集合，只能根据元素本身来访问 Queue是队列集合 Map代表的是存储key-value对的集合，可根据元素的key来访问value ","date":"2022-05-16","objectID":"https://hahaen.github.io/%E9%9B%86%E5%90%88/:1:0","tags":null,"title":"集合","uri":"https://hahaen.github.io/%E9%9B%86%E5%90%88/"},{"categories":["java知识"],"content":"对Arraylist的源码理解？ 首先，Arraylist属于线性表的结构，他其实是JDK封装的可变长数组，它的默认长度是10，当仅当第一个元素填加进来以后，他会自动把他设置成10， 然后后面再添加元素进来，其实每次都会先检查容量的大小，如果超过当前长度就会发生扩容。 Arraylist怎么扩容的？他就是底层调用c++将现在的长度变成原来的1.5倍，新数组长度等于旧数组长度加上旧数组长度右移1位。 Arraylist删除元素，比如说删除中间的一个元素，它会采用覆盖的形式将后面的元素依次往前挪，最后的一个元素就设置null,等着GC去回收掉。 Arraylist相当于在内存空间上是一段连续的空间 Arraylist：底层使用的是Object 数组。 ","date":"2022-05-16","objectID":"https://hahaen.github.io/%E9%9B%86%E5%90%88/:2:0","tags":null,"title":"集合","uri":"https://hahaen.github.io/%E9%9B%86%E5%90%88/"},{"categories":["java知识"],"content":"ArrayList和LinkedList的区别？ 首先ArrayList和LinkedList啊，他们都是实现了这个List接口，那我们的ArrayList他们是基于这个索引的一个数据接口， 他的底层是数组，那他也可以以这个O(1)的一个时间复杂度，对我们的元素进行一些随机访问，那么LinkedList呢，是以我们这个元素啊， 以我们这个元素列表的形式去存储他的这个数据，他的每一个元素和他的起前一个和后一个元素呢，链接在一起， 那在这种情况下呢，就是我们去查找某个元素的一个时间复杂度，他是O(n)的， 相对我们的ArrayList，那这个LinkedList，他的一个插入删除会比较快很多。 ArrayList的查询比较快。LinkedList新增删除比较快呢，原因是当我们这个元素被添加到这个集合的一个任意的一个位置的时候啊， 他不需要像数组那样去重新计算我们这个整个大小，或者说更新这个索引，所以LinkedList呢，他相对我们这个ArrayList，他会更占内存， 因为LinkedList他等于为了每一个节点的一个存储了两个引用，一个指向前一个元素，一个指向后一个元素啊，大概就是这样。 ","date":"2022-05-16","objectID":"https://hahaen.github.io/%E9%9B%86%E5%90%88/:3:0","tags":null,"title":"集合","uri":"https://hahaen.github.io/%E9%9B%86%E5%90%88/"},{"categories":["java知识"],"content":"HashMap 和 Hashtable区别？ 如果是在我们这个存储方面的话，我们的Hashmap是以这个key和value而是为null的，那在我们的Hashtable里面，就是不允许的。 如果是站在线程安全角度上的话，我们的Hashtable他是线程安全的，而Hashmap是非线程安全的， 我有在网上看一些资料，他们推荐使用的是说，因为在我们的Hashtable里面的一个类注释里面，是可以看到的， 我们的Hashtable是一个保留类，它是不推荐不建议我们使用的，所以比较推荐的是在我们单线程的一个环境下， 可以使用我们的HashMap去替代，如果我们有这个多线程业务的话，他是推荐我们去使用我们的这个ConcurrentHashMap去替代。 ","date":"2022-05-16","objectID":"https://hahaen.github.io/%E9%9B%86%E5%90%88/:4:0","tags":null,"title":"集合","uri":"https://hahaen.github.io/%E9%9B%86%E5%90%88/"},{"categories":["java知识"],"content":"HashMap 与 ConcurrentHashMap 区别 ","date":"2022-05-16","objectID":"https://hahaen.github.io/%E9%9B%86%E5%90%88/:5:0","tags":null,"title":"集合","uri":"https://hahaen.github.io/%E9%9B%86%E5%90%88/"},{"categories":["java知识"],"content":"HashMap 负载因子0.75 默认16，超过16*0.75=12，就会自动扩容，扩容就是翻倍。将元素移动到新数组，在1.8过程中会升级为红黑树。 HashMap从Java7到Java8发生了哪些变化？ JDK 7 是先对 size++ 进行检查， 如果超过阈值， 则扩容，最后把节点放入 table。 而 JDK 8 相反，先把节点放入， 放入后的 size 若超出， 则扩容 ","date":"2022-05-16","objectID":"https://hahaen.github.io/%E9%9B%86%E5%90%88/:6:0","tags":null,"title":"集合","uri":"https://hahaen.github.io/%E9%9B%86%E5%90%88/"},{"categories":["java知识"],"content":"Hashset HashMap分为key和value,Hashset内部实现有个HashMap，他就相当于HashMap里的key。 ","date":"2022-05-16","objectID":"https://hahaen.github.io/%E9%9B%86%E5%90%88/:7:0","tags":null,"title":"集合","uri":"https://hahaen.github.io/%E9%9B%86%E5%90%88/"},{"categories":["java知识"],"content":"Treeset 红黑树 保证一个平衡二叉树 二叉查找树：左节点比右节点小，每次查找会缩半。 ","date":"2022-05-16","objectID":"https://hahaen.github.io/%E9%9B%86%E5%90%88/:8:0","tags":null,"title":"集合","uri":"https://hahaen.github.io/%E9%9B%86%E5%90%88/"},{"categories":["java知识"],"content":"线程安全的集合有哪些？线程不安全的呢？ 线程安全的： Hashtable：比HashMap多了个线程安全。 ConcurrentHashMap:是一种高效但是线程安全的集合。 Vector：比Arraylist多了个同步化机制。 Stack：栈，也是线程安全的，继承于Vector。 线性不安全的： HashMap Arraylist LinkedList HashSet （无序） LinkedHashSet（有序） TreeSet （排序） TreeMap ","date":"2022-05-16","objectID":"https://hahaen.github.io/%E9%9B%86%E5%90%88/:9:0","tags":null,"title":"集合","uri":"https://hahaen.github.io/%E9%9B%86%E5%90%88/"},{"categories":["工具教程"],"content":"pom文件下添加配置, \u003cplugin\u003e \u003cgroupId\u003ecom.github.spotbugs\u003c/groupId\u003e \u003cartifactId\u003espotbugs-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e3.1.12\u003c/version\u003e \u003cconfiguration\u003e \u003cexcludeFilterFile\u003eignore.xml\u003c/excludeFilterFile\u003e \u003c/configuration\u003e \u003cdependencies\u003e \u003c!-- overwrite dependency on spotbugs if you want to specify the version of spotbugs --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.github.spotbugs\u003c/groupId\u003e \u003cartifactId\u003espotbugs\u003c/artifactId\u003e \u003cversion\u003e4.0.0\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003espotbugs\u003c/id\u003e \u003cphase\u003everify\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003echeck\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e ","date":"2022-05-15","objectID":"https://hahaen.github.io/spotbugs%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","tags":null,"title":"SpotBugs使用教程","uri":"https://hahaen.github.io/spotbugs%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"官方教程 ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"配置 安装node.js 安装apidoc npm install apidoc -g 在项目根目录下新建apidoc.json文件 { \"name\": \"wxshop\", \"version\": \"1.0.0\", \"description\": \"小微店铺\", \"title\": \"小微店铺\", \"url\" : \"https://localhost:8080/api/v1\" } ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"使用样例 /** * @api {post} /code 请求验证码 * @apiName GetCode * @apiGroup 登录与鉴权 * * @apiHeader {String} Accept application/json * @apiHeader {String} Content-Type application/json * * @apiParam {String} tel 手机号码 * @apiParamExample {json} Request-Example: * { * \"tel\": \"13012345678\", * } * * @apiSuccessExample Success-Response: * HTTP/1.1 200 OK * @apiError 400 Bad Request 若用户的请求包含错误 * * @apiErrorExample Error-Response: * HTTP/1.1 400 Bad Request * { * \"message\": \"Bad Request\" * } */ /** * @param telAndCode 手机号和收到的验证码 * @param response HTTP response */ @PostMapping(\"/code\") public void code(@RequestBody TelAndCode telAndCode, HttpServletResponse response) { if (telVerificationService.verifyTelParameter(telAndCode)) { authService.sendVerificationCode(telAndCode.getTel()); } else { response.setStatus(HttpStatus.BAD_REQUEST.value()); } } ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"@api @api {method} path [title] HTTP接口调用方法、路径及名称 ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:1","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"@apiVersion @apiVersion version api 版本号 ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:2","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"@apiName @apiName name api 名称 ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:3","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"@apiGroup @apiGroup name api 分组 ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:4","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"@apiHeader @apiHeader [(group)] [{type}] [field=defaultValue] [description] 请求头参数 ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:5","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"@apiParam @apiParam [(group)] [{type}] [field=defaultValue] [description] 请求参数 ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:6","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"@apiSuccess @apiSuccess [(group)] [{type}] field [description] 返回数据描述 ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:7","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"@apiSuccessExample @apiSuccessExample [{type}] [title] example 接口成功返回样例 ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:8","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"@apiError @apiError [(group)] [{type}] field [description] 接口失败描述 ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:9","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"@apiErrorExample @apiErrorExample [{type}] [title] example 接口失败返回样例 ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:10","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"@apiDefine @apiDefine name [title] [description] 类似于宏定义，可以被引用 ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:11","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"@apiUse @apiUse name 使用@apiDefine定义的描述 ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:12","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"生成文档 cd到apidoc.json所在路径（即项目根目录）执行如下命令即可 apidoc -i src/ -o apidoc/ 执行成功后会生成apidoc文件夹; 点开apidoc文件夹中index.html会发现已经生成的漂亮的api文档。 ","date":"2022-05-14","objectID":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","tags":null,"title":"Apidoc使用教程","uri":"https://hahaen.github.io/apidoc%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["笔记"],"content":"查看git快捷配置 cat ~/.bashrc ","date":"2022-05-12","objectID":"https://hahaen.github.io/git%E5%BF%AB%E6%8D%B7%E9%85%8D%E7%BD%AE/:1:0","tags":null,"title":"Git快捷配置","uri":"https://hahaen.github.io/git%E5%BF%AB%E6%8D%B7%E9%85%8D%E7%BD%AE/"},{"categories":["笔记"],"content":"修改git快捷配置 vi ~/.bashrc 例子 alias ga=\"git add\" alias gm=\"git commit -m\" alias gc=\"git commit -v\" alias gl=\"git pull\" alias gp=\"git push\" alias gco=\"git checkout\" alias gst=\"git status -sb\" alias glog=\"git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit -- | less\" ","date":"2022-05-12","objectID":"https://hahaen.github.io/git%E5%BF%AB%E6%8D%B7%E9%85%8D%E7%BD%AE/:2:0","tags":null,"title":"Git快捷配置","uri":"https://hahaen.github.io/git%E5%BF%AB%E6%8D%B7%E9%85%8D%E7%BD%AE/"},{"categories":["MySQL知识"],"content":"什么是视图？ 在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。视图包含行和列，就像一个真实的表。 视图是一种不存在的虚拟表: 类似表但是不是表。 类似表: 视图有表结构； 不是表: 没有数据, 视图的数据来源都是基表； 视图中的字段是来自一个或多个数据库中的真实的表中的字段。 单表视图: 基表只有一个； 多表视图: 基表至少两个以上； 我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据， 就像这些来自于某个单一的表。 数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。 视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。 7.可以从某个查询内部、某个存储过程内部，或者从另一个视图内部来使用视图。 通过向视图添加函数、join 等等，我们可以向用户精确地提交我们希望提交的数据。 ","date":"2022-05-05","objectID":"https://hahaen.github.io/sql%E8%A7%86%E5%9B%BE/:1:0","tags":null,"title":"Sql视图","uri":"https://hahaen.github.io/sql%E8%A7%86%E5%9B%BE/"},{"categories":["MySQL知识"],"content":"SQL CREATE VIEW 实例 SQLCREATEVIEW语法：CREATEVIEWview_nameASSELECTcolumn_name(s)FROMtable_nameWHEREcondition--创建视图-- createorreplaceviewv_studentasselectSno,Snamefromstudent;--从视图中检索数据，即查询上面这个视图-- select*fromv_student;--也可以向查询添加条件-- select*fromv_studentwhereSnamelike'%云';--删除视图-- dropviewv_student; ","date":"2022-05-05","objectID":"https://hahaen.github.io/sql%E8%A7%86%E5%9B%BE/:2:0","tags":null,"title":"Sql视图","uri":"https://hahaen.github.io/sql%E8%A7%86%E5%9B%BE/"},{"categories":["MySQL知识"],"content":"视图的作用 把经常使用的数据定义为视图，可以将复杂的SQL查询语句进行封装。 安全性，用户只能查询和修改能看到的数据。 使用视图，基表中的数据就有了一定的安全性。因为视图是虚拟的，物理上是不存在的, 只是存储了数据的集合，我们可以不通过视图将基表中重要的字段信息给用户。 视图是动态的数据的集合，数据是随着基表的更新而更新的。 同时，用户对视图，不可以随意的更改和删除，可以保证数据的安全性。 逻辑上的独立性，屏蔽了真实表的结构带来的影响。 视图的存在: 主要是为了对外提供数据支持(外部系统)； 隐藏了基表字段(隐私)； 保证了数据库的数据安全(保护数据库内部的数据结构)； 可以灵活的控制对外的数据: 保证针对每个接口都有一个单独的数据支持，增强了用户友好性。 ","date":"2022-05-05","objectID":"https://hahaen.github.io/sql%E8%A7%86%E5%9B%BE/:3:0","tags":null,"title":"Sql视图","uri":"https://hahaen.github.io/sql%E8%A7%86%E5%9B%BE/"},{"categories":["MySQL知识"],"content":"视图的缺点 性能差 数据库必须把视图查询转化成对基本表的查询， 如果这个视图是由一个复杂的多表查询所定义，那么即使是视图的一个简单查询， 数据库也要把它变成一个复杂的结合体，需要花费一定的时间。 修改限制 当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改， 对于简单的视图来说，这是很方便的，但是，对于比较复杂的试图，可能是不可修改的。 在定义数据库对象时，不能不加选择地来定义视图，应该权衡视图的优点和缺点，合理地定义视图。 对视图的修改：（1）单表视图操作: 可以进行增删改, 但是要实现新增: 前提是视图必须包含基表的所有不能为空的字段。 （2）多表视图(基表来源两个以上)不能插入数据, 也不能删除数据，但是可以修改数据。 使用视图还是有很多局限性的，并没有像直接使用表那么方便。 如果视图定义中包含了group by、union、聚合函数以及其他一些特殊情况， 就不能被更新了；更新视图的查询也可以是一个关联语句， 但是被更新的列必须来自同一张表；而且所有使用临时表算法实现的视图都无法被更新。 ","date":"2022-05-05","objectID":"https://hahaen.github.io/sql%E8%A7%86%E5%9B%BE/:4:0","tags":null,"title":"Sql视图","uri":"https://hahaen.github.io/sql%E8%A7%86%E5%9B%BE/"},{"categories":["java知识"],"content":"Spring、SpringMVC、SpringBoot区别是什么？ ","date":"2022-04-29","objectID":"https://hahaen.github.io/spring/:1:0","tags":null,"title":"Spring","uri":"https://hahaen.github.io/spring/"},{"categories":["java知识"],"content":"SpringBoot 到 SpringMVC 的改进是： 自动化配置: SpringMVC通过xml配置，手动指定。SpringBoot通过注解或者自动化扫描当前项目中存在哪些第三方包。 SpringBoot自带Servlet容器，可以直接启动。SpringMVC不自带，需要额外的配置，例如TomCat SpringBoot能直接打成jar包，可直接启动 ","date":"2022-04-29","objectID":"https://hahaen.github.io/spring/:1:1","tags":null,"title":"Spring","uri":"https://hahaen.github.io/spring/"},{"categories":["java知识"],"content":"区别 Spring 就像一个大家族，有众多衍生产品例如 Boot，Security，JPA等等。但他们的基础都是Spring 的 IOC 和 AOP，IOC提供了依赖注入的容器， 而AOP解决了面向切面的编程 Spring MVC是基于 Servlet 的一个 MVC 框架，主要解决 WEB 开发的问题， 为了简化开发者的使用，Spring社区创造性地推出了Spring Boot，它遵循约定优于配置， Spring MVC和Spring Boot都属于Spring，Spring MVC 是基于Spring的一个 MVC 框架，而Spring Boot 是基于Spring的一套快速开发整合包 ","date":"2022-04-29","objectID":"https://hahaen.github.io/spring/:1:2","tags":null,"title":"Spring","uri":"https://hahaen.github.io/spring/"},{"categories":["java知识"],"content":"Bean生命周期 ","date":"2022-04-29","objectID":"https://hahaen.github.io/spring/:2:0","tags":null,"title":"Spring","uri":"https://hahaen.github.io/spring/"},{"categories":["java知识"],"content":"Spring容器 ","date":"2022-04-29","objectID":"https://hahaen.github.io/spring/:3:0","tags":null,"title":"Spring","uri":"https://hahaen.github.io/spring/"},{"categories":["分析"],"content":"高并发三种处理方式 系统拆分 缓存 MQ ","date":"2022-04-21","objectID":"https://hahaen.github.io/%E7%94%B5%E5%95%86/:1:0","tags":null,"title":"电商","uri":"https://hahaen.github.io/%E7%94%B5%E5%95%86/"},{"categories":["分析"],"content":"做项目的时候，如果我们有个变量，我们需要在上下文一直传递下去，那这个时候怎么去弄呢？ 可以用Threadlocal，或者是它的子类，这样的话主线程跟子线程之间可以通信，也能相互传递。 你有了解过它的原理吗？ 原理其实就是一个空间换时间的这样的概念嘛，他本身是有两层Map，嵌套在里头的。 ","date":"2022-04-21","objectID":"https://hahaen.github.io/%E7%94%B5%E5%95%86/:2:0","tags":null,"title":"电商","uri":"https://hahaen.github.io/%E7%94%B5%E5%95%86/"},{"categories":["分析"],"content":"秒杀减库存 扣件库存就是先发送一个半消息，然后使用lua(撸啊)脚本加Redis,在接入层直接扣件库存Redis库存， 然后异步写数据库达到数据一致性，如果出现问题的话回滚数据，就是去扫表，然后达到一个最终的一致性。 ","date":"2022-04-21","objectID":"https://hahaen.github.io/%E7%94%B5%E5%95%86/:3:0","tags":null,"title":"电商","uri":"https://hahaen.github.io/%E7%94%B5%E5%95%86/"},{"categories":["分析"],"content":"类似电商的项目，什么支付功能，还有什么秒杀功能，就是有没有遇到什么问题，后来又是怎么解决的？ 遇到的问题是吧，那这个也是很普遍，就是我们会遇到这个大量的这个用户访问到我们这个服务器上面的这些情况，那站在服务器层面上的，这个资源都是有限的嘛， 那我们只能用这些有限的资源去处理这些大量用户的请求，而且还要求我们效率还要快嘛，那我的处理方案就是把这个流量呢， 分担到一个更大宽度的一个时间点嘛，比如说我们加一点这个验证码功能，加入购物车这些功能啊，都可以实现一个分流嘛， 然后前端限流，后端也要限流，就是我们限制他次数，限制它的总量啊，然后快速的一个失败降级运行啊，还要我们的熔断隔离防止这个雪崩， 就比如说我们一万个商品嘛，然后每个是1000件去秒杀，那考虑到这些所有的一个秒杀成功的请求呢，其实我们是要去进入队列啊，就是要去写一个队列， 慢慢去创建我们的订单，再去扣减我们的这个库存嘛，那库存那边也要去做一个预热嘛，就放到我们的redis，然后信号量去控制我们的秒杀请求， 然后我们的nginx去做好我们的一个动静分离，静态资源啊，我们的nginx要直接返回，要保证我们的秒杀和我们的这个商品详情页的一个动态请求， 请求后才可以打开我们这么个后端服务集群，差不多就这样。 像这种系统我们肯定还要考虑它的安全嘛，就是我们要避免一些恶意攻击嘛，然后我们也要避免我们的一个链接暴露嘛，就是怕我们的一个工作人员嘛， 知道链接了他们去提前去秒杀这个商品所以我们要给这个秒杀链接，要去加密，然后我们肯定也会遇到很多这种脚本的恶意请求，然后我们也要去做做这些相应的一个拦截， 就是我们这个服务网关识别，它的这么一个非法的攻击请求，然后去进行我们的一个拦截，那在这种场景下，就是短时间内的这个数据库它的一个访问量会非常高， 它的一个读写量也会很高，所以我们也应该去分库分表，然后去拓展更多的数据库。然后去应对我们的这么高的一个写流量嘛，然后在后台要去启动若干个这个队列， 去处理我们这个程序，消费MQ中的一个消息嘛，再去执行我们的一个校验库存啊，然后还要我们这些下单啊，这样的。 ","date":"2022-04-21","objectID":"https://hahaen.github.io/%E7%94%B5%E5%95%86/:4:0","tags":null,"title":"电商","uri":"https://hahaen.github.io/%E7%94%B5%E5%95%86/"},{"categories":["分析"],"content":"怎么完善这个系统？ 其实我那个的时候就去考虑了，就是使用消息队列去降低业务系统嘛，还有就是数据系统的一个直接耦合度嘛， 然后我们还想要去抵挡我们的这么个高并发的写流量，比如说做一些缓存啊，做一些日志啊，做一些监控之类的东西， 当然还有我们的负载均衡啊，我们的动态路由啊，去使用那个阻塞队列嘛，使用阻塞队列线程池的方式啊， 让这些拥护先去拿到秒杀资格，然后我们再通过计算，去返回给客服嘛，那那会呢我还一直想的就是我们的异步处理， 其实是提升我们这个系统性能的一个神器，但是呢，我们需要分清楚这个同步的一个流程，和异步的一个流程，他们这个的一个边界， 就是这里面的消息啊，他存在的一些会丢失的一些风险啊，所以其实当时也是考虑到的说去怎么去保证这些消息能够一定能够达到。 ","date":"2022-04-21","objectID":"https://hahaen.github.io/%E7%94%B5%E5%95%86/:5:0","tags":null,"title":"电商","uri":"https://hahaen.github.io/%E7%94%B5%E5%95%86/"},{"categories":["工具教程"],"content":" 在pom.xml添加配置 \u003cplugin\u003e \u003cgroupId\u003eorg.jacoco\u003c/groupId\u003e \u003cartifactId\u003ejacoco-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e0.8.5\u003c/version\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003edefault-prepare-agent\u003c/id\u003e \u003cgoals\u003e \u003cgoal\u003eprepare-agent\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003cexecution\u003e \u003cid\u003edefault-report\u003c/id\u003e \u003cphase\u003everify\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003ereport\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003cexecution\u003e \u003cid\u003edefault-check\u003c/id\u003e \u003c!-- \u003cgoals\u003e--\u003e \u003c!-- \u003cgoal\u003echeck\u003c/goal\u003e--\u003e \u003c!-- \u003c/goals\u003e--\u003e \u003cconfiguration\u003e \u003crules\u003e \u003crule\u003e \u003celement\u003eBUNDLE\u003c/element\u003e \u003climits\u003e \u003climit\u003e \u003ccounter\u003eCOMPLEXITY\u003c/counter\u003e \u003cvalue\u003eCOVEREDRATIO\u003c/value\u003e \u003cminimum\u003e0.60\u003c/minimum\u003e \u003c/limit\u003e \u003c/limits\u003e \u003c/rule\u003e \u003c/rules\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e 当JaCoCo插件配置好以后，要获得 JaCoCo的统计数据，就要执行mvn install 命令。 执行完以后，target/site/jacoco/目录下会生成一个index.html文件. 这是统计数据总览页面，可以在浏览器打开查看 在该目录下可查看测试报告 ","date":"2022-04-10","objectID":"https://hahaen.github.io/jacoco%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"Jacoco使用教程","uri":"https://hahaen.github.io/jacoco%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"Mybatis Generator（MBG）的作用 ：根据库中的表自动生成dao、mapper映射文件、实体类 在pom.xml添加配置 \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.mybatis.generator\u003c/groupId\u003e \u003cartifactId\u003emybatis-generator-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e1.3.2\u003c/version\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.48\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cconfiguration\u003e \u003c!--指定generatorConfig.xml 配置文件的路径 --\u003e \u003cconfigurationFile\u003e${basedir}/src/main/resources/generatorConfig.xml\u003c/configurationFile\u003e \u003coverwrite\u003etrue\u003c/overwrite\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e 将generatorConfig.xml配置文件放入main/resource目录下 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"\u003e \u003cgeneratorConfiguration\u003e \u003ccontext id=\"test\" targetRuntime=\"MyBatis3\"\u003e \u003cplugin type=\"org.mybatis.generator.plugins.EqualsHashCodePlugin\"/\u003e \u003cplugin type=\"org.mybatis.generator.plugins.SerializablePlugin\"/\u003e \u003cplugin type=\"org.mybatis.generator.plugins.ToStringPlugin\"/\u003e \u003ccommentGenerator\u003e \u003c!-- 这个元素用来去除指定生成的注释中是否包含生成的日期 false:表示包含 --\u003e \u003c!-- 如果生成日期，会造成即使修改一个字段，整个实体类所有属性都会发生变化，不利于版本控制，所以设置为true --\u003e \u003cproperty name=\"suppressDate\" value=\"true\" /\u003e \u003c!-- 是否去除自动生成的注释 true：是 ： false:否 --\u003e \u003cproperty name=\"suppressAllComments\" value=\"true\" /\u003e \u003c/commentGenerator\u003e \u003c!--数据库链接URL，用户名、密码 --\u003e \u003cjdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/test\" userId=\"root\" password=\"root\"\u003e \u003c/jdbcConnection\u003e \u003cjavaTypeResolver\u003e \u003c!-- 浮点精度更高 --\u003e \u003cproperty name=\"forceBigDecimals\" value=\"false\" /\u003e \u003c/javaTypeResolver\u003e \u003c!-- 生成模型(entity)的包名和位置 --\u003e \u003cjavaModelGenerator targetPackage=\"com.bz.entity\" targetProject=\"src/main/java\"\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c!-- enableSubPackages：是否要合并当前两个包 合并之后的包结构是src/main/java/com.bz.entity --\u003e \u003cproperty name=\"trimStrings\" value=\"true\" /\u003e \u003c!-- 是否去除生成实体类中的空格 --\u003e \u003c/javaModelGenerator\u003e \u003c!-- 生成映射文件的包名和位置 --\u003e \u003csqlMapGenerator targetPackage=\"com.bz.mapper\" targetProject=\"src/main/resources\"\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c/sqlMapGenerator\u003e \u003c!-- 生成DAO的包名和位置 --\u003e \u003cjavaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.bz.dao\" targetProject=\"src/main/java\"\u003e \u003c!--类型就是XMLMAPPER，不用改--\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c/javaClientGenerator\u003e \u003c!-- 数据库中生成哪些表 有多少表就写几个table标签 tableName：数据库中表名 domainObjectName：生成的实体类名 --\u003e \u003ctable tableName=\"files\" domainObjectName=\"Files\"\u003e\u003c/table\u003e \u003c/context\u003e \u003c/generatorConfiguration\u003e 需要修改的有： 数据库链接URL，用户名、密码 生成模型(entity)的包名 生成映射文件的包名 生成DAO的包名 数据库中生成哪些表 自动在设定位置生成dao、mapper映射文件、实体类 mvn mybatis-generator:generate ","date":"2022-04-08","objectID":"https://hahaen.github.io/mybatis-generator%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"MyBatis Generator使用教程","uri":"https://hahaen.github.io/mybatis-generator%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":" checkstyle.xml模板 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE module PUBLIC \"-//Puppy Crawl//DTD Check Configuration 1.3//EN\" \"http://www.puppycrawl.com/dtds/configuration_1_3.dtd\"\u003e \u003cmodule name=\"Checker\"\u003e \u003c!-- 官方主页：https://checkstyle.sourceforge.io --\u003e \u003c!-- 检查文件是否以一个空行结束 --\u003e \u003cmodule name=\"NewlineAtEndOfFile\"/\u003e \u003c!-- 文件长度不超过1500行 --\u003e \u003cmodule name=\"FileLength\"\u003e \u003cproperty name=\"max\" value=\"1500\"/\u003e \u003c/module\u003e \u003c!-- 每行不超过120个字 --\u003e \u003cmodule name=\"LineLength\"\u003e \u003cproperty name=\"max\" value=\"150\"/\u003e \u003c/module\u003e \u003cmodule name=\"TreeWalker\"\u003e \u003c!-- 想严格对文件头进行检查，请把文件头定义在一个外部文件中，如：java_header_file.txt 然后使 用\"headerFile\"属性： \u003cmodule name=\"Header\"\u003e \u003cproperty name=\"headerFile\" value=\"java_header_file.txt\"/\u003e \u003cproperty name=\"ignoreLines\" value=\"1, 5\"/\u003e \u003c/module\u003e --\u003e \u003c!-- 忽略掉文件头的几行声明 不指定外部文件时出错，暂不使用 \u003cmodule name=\"Header\"\u003e \u003cproperty name=\"ignoreLines\" value=\"1, 5\"/\u003e \u003c/module\u003e --\u003e \u003c!-- ********************************javadoc的检查********************--\u003e \u003c!-- 检查Javadoc --\u003e \u003cmodule name=\"JavadocStyle\"\u003e \u003c!-- 忽略句号结尾检查 --\u003e \u003cproperty name='checkFirstSentence' value='false'/\u003e \u003cproperty name='checkEmptyJavadoc' value='true'/\u003e \u003c/module\u003e \u003c!-- 检查所有的interface和class的doc --\u003e \u003cmodule name=\"JavadocType\"\u003e \u003c!-- 注释里允许所有注解 --\u003e \u003cproperty name='allowUnknownTags' value='true'/\u003e \u003c/module\u003e \u003c!-- 检查所有方法的javadoc 注意方法上的@param XXX后必须跟参数说明检查才能通过 --\u003e \u003cmodule name='MissingJavadocMethod'\u003e \u003cproperty name=\"allowMissingPropertyJavadoc\" value=\"true\"/\u003e \u003cproperty name=\"allowedAnnotations\" value=\"Override,Deprecated,ApiOperation\"/\u003e \u003cproperty name=\"ignoreMethodNamesRegex\" value=\"main\"/\u003e \u003c/module\u003e \u003cmodule name=\"JavadocMethod\"/\u003e \u003c!-- 变量的javadoc --\u003e \u003cmodule name=\"JavadocVariable\"\u003e \u003c!-- 忽略检查的变量名 --\u003e \u003cproperty name='ignoreNamePattern' value='.*Business|.*Service|.*Handler|.*Mapper|.*Template|.*Client|.*Util.*|LOG|LOGGER'/\u003e \u003c/module\u003e \u003c!-- ********************************import方面的检查*********** --\u003e \u003c!-- import中避免星号\"*\" --\u003e \u003cmodule name=\"AvoidStarImport\"/\u003e \u003c!-- 检查是否从非法的包中导入了类 --\u003e \u003cmodule name=\"IllegalImport\"/\u003e \u003c!-- 检查是否导入了多余的包 --\u003e \u003cmodule name=\"RedundantImport\"/\u003e \u003c!--没用的import检查，比如：1.没有被用到 2.重复的 3.import java.lang的 4.import与该类在同一个package的--\u003e \u003cmodule name=\"UnusedImports\"/\u003e \u003c!-- ********************************命名规则检查****************** --\u003e \u003c!-- 包名检查 ^[a-z]+(\\.[a-z][a-z0-9]*)*$ --\u003e \u003cmodule name=\"PackageName\"\u003e \u003cproperty name=\"format\" value=\"^[a-z]+(\\.[a-z][a-z0-9]*)*$\"/\u003e \u003cmessage key=\"name.invalidPattern\" value=\"包名 ''{0}'' 要符合 ''{1}''格式.\"/\u003e \u003c/module\u003e \u003c!-- 类型(Class或Interface)名 ^[A-Z][a-zA-Z0-9]*$--\u003e \u003cmodule name=\"TypeName\"\u003e \u003cproperty name=\"severity\" value=\"warning\"/\u003e \u003cmessage key=\"name.invalidPattern\" value=\"名称 ''{0}'' 要符合 ''{1}''格式.\"/\u003e \u003c/module\u003e \u003c!-- 方法名 ^[a-z][a-zA-Z0-9]*$--\u003e \u003cmodule name=\"MethodName\"/\u003e \u003c!-- 方法的参数命名 ^[a-z][a-zA-Z0-9]*$--\u003e \u003cmodule name=\"ParameterName \"/\u003e \u003c!-- 非static型变量 ^[a-z][a-zA-Z0-9]*$--\u003e \u003cmodule name=\"MemberName\"/\u003e \u003c!-- 常量(static , final 字段) ^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$--\u003e \u003cmodule name=\"ConstantName\"/\u003e \u003c!-- 局部的final变量，包括catch中的参数 ^[a-z][a-zA-Z0-9]*$ --\u003e \u003cmodule name=\"LocalFinalVariableName\"/\u003e \u003c!-- 局部的非final型的变量，包括catch中的参数 ^[a-z][a-zA-Z0-9]*$ --\u003e \u003cmodule name=\"LocalVariableName\"/\u003e \u003c!-- 仅仅是static型的变量（不包括staticfinal型） ^[a-z][a-zA-Z0-9]*$ --\u003e \u003cmodule name=\"StaticVariableName\"/\u003e \u003c!-- **************方法的参数个数不超过5个。 并且不对构造方法和重写方法进行检查*******--\u003e \u003cmodule name=\"ParameterNumber\"\u003e \u003cproperty name=\"tokens\" value=\"METHOD_DEF\"/\u003e \u003cproperty name=\"ignoreOverriddenMethods\" value=\"true\"/\u003e \u003cproperty name=\"max\" value=\"5\"/\u003e \u003c/module\u003e \u003c!-- ************************代码行数及行代码长度限制****************** --\u003e \u003c!-- 文件长度不超过1500行，放在TreeWalker前面 --\u003e \u003c!-- 方法不超过300行 --\u003e \u003cmodule name=\"MethodLength\"\u003e \u003cproperty name=\"tokens\" value=\"METHOD_DEF\"/\u003e \u003cproperty name=\"max\" value=\"300\"/\u003e \u003c/module\u003e \u003c!-- 每行不超过120个字 \u003cmodule name=\"LineLength\"\u003e \u003cproperty name=\"max\" value=\"150\"/\u003e \u003c/module\u003e --\u003e \u003c!-- ****************************空格限定***************************** --\u003e \u003c!-- 检查约定方法名与左边圆括号之间不许出现空格 public void wrongStyleMethod (){ public void wrongStyleMethod (String para1, String para2){ 都是不能通过的，只允许方法名后紧跟左边圆括号\"(\"--\u003e \u003cmodule name=\"MethodParamPad\"/\u003e \u003c!-- 不允许左圆括号右边有","date":"2022-04-08","objectID":"https://hahaen.github.io/checkstyle%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"Checkstyle使用教程","uri":"https://hahaen.github.io/checkstyle%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具教程"],"content":"官网 引入Maven plugin \u003cplugin\u003e \u003cgroupId\u003eorg.flywaydb\u003c/groupId\u003e \u003cartifactId\u003eflyway-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e6.2.4\u003c/version\u003e \u003cconfiguration\u003e \u003cuser\u003eroot\u003c/user\u003e \u003cpassword\u003eroot\u003c/password\u003e \u003curl\u003ejdbc:mysql://localhost:3306/xxx\u003c/url\u003e \u003c/configuration\u003e \u003c/plugin\u003e 创建目录 在resources下创建目录db 在目录db创建目录migration 在目录migration下创建文件V1__Create_User.sql 在文件V1__Create_User.sql下写相应sql 如图 mvn flyway:clean mvn flyway:migrate ","date":"2022-04-07","objectID":"https://hahaen.github.io/flyway%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"Flyway使用教程","uri":"https://hahaen.github.io/flyway%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["网络"],"content":"tcp和udp的区别 ","date":"2022-04-05","objectID":"https://hahaen.github.io/java%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:1:0","tags":null,"title":"Java网络基础","uri":"https://hahaen.github.io/java%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["网络"],"content":"三次握手与四次挥手 ","date":"2022-04-05","objectID":"https://hahaen.github.io/java%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:2:0","tags":null,"title":"Java网络基础","uri":"https://hahaen.github.io/java%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["java知识"],"content":"什么是AOP? ","date":"2022-04-04","objectID":"https://hahaen.github.io/aop/:1:0","tags":null,"title":"AOP","uri":"https://hahaen.github.io/aop/"},{"categories":["java知识"],"content":" IOC,就是我们的控制反转，就是把我们些好的这个对象的一个控制权交给我们的spring框架，那我们的spring框架来帮我们去控制这个对象的生命周期， 比如说我们的创建啊，销毁啊，这些处理这些对象之间的一个依赖关系， 就是我们不用主动去new这些对象，IOC就是由专门的一个容器，就去帮忙去创建这些对象， 把所有的类啊，都放到我们这个spring容器中去登记，那当我们需要这些某个对象的时候， 只需要告诉spring这个容器，就是这个spring就会在我们系统中去运行到一个适当的时机， 然后呢把想要的一个对象主动给到我们这边，那以前呢是都是由我们自己去主动控制他所引用这个对象的一个生命周期， 那在这个IOC里面，就是所以的对象都会被spring控制，所以也是被我们称为控制反正的原因。 ","date":"2022-04-04","objectID":"https://hahaen.github.io/ioc/:0:0","tags":null,"title":"IOC","uri":"https://hahaen.github.io/ioc/"},{"categories":["java知识"],"content":"为什么会出现跨域问题 出于浏览器的同源策略限制。 同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能， 如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。 可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。 同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。 所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。 ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:1:0","tags":null,"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"什么是跨域 当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域 ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:2:0","tags":null,"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"非同源限制 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB 无法接触非同源网页的 DOM 无法向非同源地址发送 AJAX 请求 ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:3:0","tags":null,"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"java后端实现CORS跨域请求的方式 对于 CORS的跨域请求，主要有以下几种方式可供选择： 返回新的CorsFilter 重写 WebMvcConfigurer 使用注解 @CrossOrigin 手动设置响应头 (HttpServletResponse) 自定web filter实现跨域(推荐) ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:4:0","tags":null,"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"1.返回新的CorsFilter 在任意配置类，返回一个 新的 CorsFIlter Bean ，并添加映射路径和具体的CORS配置路径。 @Configuration public class GlobalCorsConfig { @Bean public CorsFilter corsFilter() { //1. 添加 CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //放行哪些原始域 config.addAllowedOrigin(\"*\"); //是否发送 Cookie config.setAllowCredentials(true); //放行哪些请求方式 config.addAllowedMethod(\"*\"); //放行哪些原始请求头部信息 config.addAllowedHeader(\"*\"); //暴露哪些头部信息 config.addExposedHeader(\"*\"); //2. 添加映射路径 UrlBasedCorsConfigurationSource corsConfigurationSource = new UrlBasedCorsConfigurationSource(); corsConfigurationSource.registerCorsConfiguration(\"/**\",config); //3. 返回新的CorsFilter return new CorsFilter(corsConfigurationSource); } } ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:4:1","tags":null,"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"2.重写 WebMvcConfigurer @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"/**\") //是否发送Cookie .allowCredentials(true) //放行哪些原始域 .allowedOrigins(\"*\") .allowedMethods(new String[]{\"GET\", \"POST\", \"PUT\", \"DELETE\"}) .allowedHeaders(\"*\") .exposedHeaders(\"*\"); } } ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:4:2","tags":null,"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"3.使用注解 @CrossOrigin 在控制器(类上)上使用注解 @CrossOrigin，表示该类的所有方法允许跨域。 @RestController @CrossOrigin(origins = \"*\") public class HelloController { @RequestMapping(\"/hello\") public String hello() { return \"hello world\"; } } 在方法上使用注解 @CrossOrigin @RequestMapping(\"/hello\") @CrossOrigin(origins = \"*\") //@CrossOrigin(value = \"http://localhost:8081\") //指定具体ip允许跨域 public String hello() { return \"hello world\"; } ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:4:3","tags":null,"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"4.手动设置响应头 (HttpServletResponse) 使用 HttpServletResponse 对象添加响应头(Access-Control-Allow-Origin)来授权原始域， 这里 Origin的值也可以设置为 “*”,表示全部放行。 @RequestMapping(\"/index\") public String index(HttpServletResponse response) { response.addHeader(\"Access-Allow-Control-Origin\",\"*\"); return \"index\"; } ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:4:4","tags":null,"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["java知识"],"content":"5.自定web filter实现跨域(推荐) 首先编写一个过滤器，可以起名字为MyCorsFilter.java package com.mesnac.aop; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletResponse; import org.springframework.stereotype.Component; @Component public class MyCorsFilter implements Filter { public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) res; response.setHeader(\"Access-Control-Allow-Origin\", \"*\"); response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, DELETE\"); response.setHeader(\"Access-Control-Max-Age\", \"3600\"); response.setHeader(\"Access-Control-Allow-Headers\", \"x-requested-with,content-type\"); chain.doFilter(req, res); } public void init(FilterConfig filterConfig) {} public void destroy() {} } ","date":"2022-04-01","objectID":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/:4:5","tags":null,"title":"SpringBoot中的5种跨域","uri":"https://hahaen.github.io/springboot%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%B7%A8%E5%9F%9F/"},{"categories":["笔记"],"content":"提交指南 例子： ","date":"2022-03-31","objectID":"https://hahaen.github.io/github%E6%8F%90%E4%BA%A4%E6%8C%87%E5%8D%97/:1:0","tags":null,"title":"Github提交指南","uri":"https://hahaen.github.io/github%E6%8F%90%E4%BA%A4%E6%8C%87%E5%8D%97/"},{"categories":["工具教程"],"content":" 启动hugo服务(预览) hugo server -D 创建MD hugo new posts/名字.md 构建页面 hugo -D ","date":"2022-03-31","objectID":"https://hahaen.github.io/hugo%E6%8C%87%E5%8D%97/:0:0","tags":null,"title":"Hugo指南","uri":"https://hahaen.github.io/hugo%E6%8C%87%E5%8D%97/"},{"categories":["MySQL知识"],"content":"MYSQL优化经验 比较浅的层面上。 首先我们对这个查询去进行一些优化，要避免这些全表的一个扫描嘛，首先就是考虑到我们的where还有我们的order by , 这些设计的这些列上面去建立这个索引，就是我们要去避免在where子句中呢，去使用到这些!=或者说\u003e、\u003c这些操作符啊，否则我们的引擎呢，将会放弃使用我们的索引呢，也就是最左原则， 然后去进行我们的一个全表扫描，然后也要尽量的使用我们的一些，数字型的一些字段，如果我们只是含这些数值类型的字段的话， 尽量不要设置为这个字符型，这样会降低我们的一个查询，和我们的性能的一个，我们连接的一个性能嘛， 然后也会增加我们的一个存储开销，这个是因为引擎在我们的处理查询和连接的， 这会呢会逐个去比较我们的一个字符串中一个，每个字符嘛，然后对我们的这个数字型的话呢，就是只需要比较一次就够了， 然后我在学习的时候呢，我们老师有建议我不要使用到我们的select * from ,用这个具体的这个字列，去代表我们的*， 然后是不要去返回我们用不到的这些任何字段，然后避免我们这个频繁的创建和删除我们的一个临时表，以使用来减少我们这个系统表资源的这个消耗。 也要尽量少用我们的这个in关键字，可以通过我们的left join呢， 或者其他关键字去取代，然后像我们的数据库服务器集群嘛， 然后我们读写分离啊，如果对数据不经常更新，然后查询方式比较固定的这些情况下呢，可以修改我们的数据库的这个配置文件， 然后去实现我们的一个查询缓存，JVM也有做一些简单的垃圾的一个收集器，还有我们禁用类验证的一些调优， 这些都是有做过一些性能还有压力测试的一些功能的一些工具，然后去测试分析过。 ","date":"2022-03-21","objectID":"https://hahaen.github.io/sql%E4%BC%98%E5%8C%96/:1:0","tags":null,"title":"SQL优化","uri":"https://hahaen.github.io/sql%E4%BC%98%E5%8C%96/"},{"categories":["MySQL知识"],"content":"如何判断SQL查询中是否使用了索引？ 首先查找到SQL的瓶颈，MySQL使用explain，查看里面的type(数据访问)，ALL全表、index索引、range范围 优化： 例如一个业务场景特别慢，先执行这个慢SQL，使用explain,分析常见场景，在where里面有针对性的为他创建索引，使查询都走这个索引，然后具体分析。 ","date":"2022-03-21","objectID":"https://hahaen.github.io/sql%E4%BC%98%E5%8C%96/:2:0","tags":null,"title":"SQL优化","uri":"https://hahaen.github.io/sql%E4%BC%98%E5%8C%96/"},{"categories":["MySQL知识"],"content":"图 ","date":"2022-03-21","objectID":"https://hahaen.github.io/sql%E4%BC%98%E5%8C%96/:3:0","tags":null,"title":"SQL优化","uri":"https://hahaen.github.io/sql%E4%BC%98%E5%8C%96/"},{"categories":["运维"],"content":"服务器配置java injdk.cn 各种JAVA JDK的镜像分发 ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:1:0","tags":null,"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"配置docker ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:2:0","tags":null,"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"下载代码 如 ： git clone https://github.com/hahaen/wxshop.git ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:3:0","tags":null,"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"启动MySQL docker run -d -v `pwd`/wxshop-data:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=wxshop --name=wxshop-mysql mysql 需要改成自己地址 创建order数据库 docker exec -it wxshop-mysql mysql -uroot -proot -e 'create database if not exists `order`' ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:4:0","tags":null,"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"redis docker run -p 6379:6379 -d redis ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:5:0","tags":null,"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"zookeeper docker run -p 2181:2181 -d zookeeper ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:6:0","tags":null,"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"nginx events{} http { include mime.types; upstream app { server 172.23.0.1:8080; server 172.23.0.1:8081; } server { location /api { proxy_pass http://app; } location / { root /static; autoindex on; } } } 注意：如果只有 html 是对的，css js 都写错写成了 text/plain 而不是 text/css 一定要在配置加上include mime.types; 改成机器上的ip 启动nginx start_nginx.sh docker run -d -p 5000:80 -v 文件目录/build:/static -v (/root/nginx-conf/nginx.conf)配置目录:/etc/nginx/nginx.conf nginx ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:7:0","tags":null,"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"tmux 终端复用器 tmux教程 创建0：tmux new -s 0 创建1：tmux new -s 1 查看所有tmux: tmux ls 重新接入已存在的会话：tmux attach -t 0 退出（下次可进入）：Ctrl+b 再单独按d 退出（杀死）：Ctrl+d ","date":"2022-03-20","objectID":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/:8:0","tags":null,"title":"分布式部署","uri":"https://hahaen.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"},{"categories":["java知识"],"content":"加密盐 加密盐也是比较常听到的一个概念，盐就是一个随机字符串用来和我们的加密串拼接后进行加密。 加盐主要是为了提供加密字符串的安全性。 假如有一个加盐后的加密串，黑客通过一定手段这个加密串，他拿到的明文，并不是我们加密前的字符串， 而是加密前的字符串和盐组合的字符串，这样相对来说又增加了字符串的安全性。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"常用加密算法","uri":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"加密过程(用户注册) 最终的密文是以下两个内容的函数： 用户输入的密码明文 盐值 最后要将以下内容存入数据库： 用户的用户名 最终的密文 加密所用的盐值 ","date":"2022-03-16","objectID":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:1","tags":null,"title":"常用加密算法","uri":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"校验过程(用户登录) ","date":"2022-03-16","objectID":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:1:2","tags":null,"title":"常用加密算法","uri":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"不可逆加密 常见的不可逆加密算法有MD5，HMAC，SHA1、SHA-224、SHA-256、SHA-384，和SHA-512 其中SHA-224、SHA-256、SHA-384，和SHA-512我们可以统称为SHA2加密算法 SHA加密算法的安全性要比MD5更高，而SHA2加密算法比SHA1的要高。 其中SHA后面的数字表示的是加密后的字符串长度，SHA1默认会产生一个160位的信息摘要。 不可逆加密算法最大的特点就是密钥 ","date":"2022-03-16","objectID":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"常用加密算法","uri":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"对称加密算法 对称加密算法是应用比较早的算法，在数据加密和解密的时用的都是同一个密钥，这就造成了密钥管理困难的问题。 常见的对称加密算法有DES、3DES、AES128、AES192、AES256 (默认安装的 JDK 尚不支持 AES256，需要安装对应的 jce 补丁进行升级 jce1.7，jce1.8)。 其中AES后面的数字代表的是密钥长度。对称加密算法的安全性相对较低，比较适用的场景就是内网环境中的加解密。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:3:0","tags":null,"title":"常用加密算法","uri":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"非对称加密算法 非对称加密算法有两个密钥，这两个密钥完全不同但又完全匹配。 只有使用匹配的一对公钥和私钥，才能完成对明文的加密和解密过程。 常见的非对称加密有RSA、SM2等。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:4:0","tags":null,"title":"常用加密算法","uri":"https://hahaen.github.io/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"Shiro框架 是一个轻量级的安全框架，主要提供了 授权、认证、加密、会话管理这几个功能。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:1:0","tags":null,"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"shiro安全数据源有哪些 数据库 静态ini文件 session ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:2:0","tags":null,"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"Shiro运行流程 比如一个登陆流程： 首先调用Subject.login(token)进行登录，他会委托给SecurityManager SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证； Authenticator会把相应的token传入Realm，从Realm获取身份验证信息， 如果没有就返回认证失败，有的话就继续执行操作。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:3:0","tags":null,"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"Shiro 的优点 简单的身份认证, 支持多种数据源；非常简单的加密 API； 对角色的简单的授权, 支持细粒度的授权(方法级)； 支持一级缓存，以提升应用程序的性能； 内置的基于 POJO 企业会话管理, 适用于 Web 以及非 Web 的环境； 不跟任何的框架或者容器捆绑, 可以独立运行。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:4:0","tags":null,"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"Shiro 的3个核心组件 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:5:0","tags":null,"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"Subject 正与系统进行交互的人, 或某一个第三方服务。 所有 Subject 实例都被绑定到一个SecurityManager 上。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:5:1","tags":null,"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"SecurityManager Shiro 架构的心脏, 用来协调内部各安全组件, 管理内部组件实例, 并通过它来提供安全管理的各种服务。 当 Shiro 与一个 Subject 进行交互时, 实质上是幕后的 SecurityManager 处理所有繁重的 Subject 安全操作。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:5:2","tags":null,"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"Realms 本质上是一个特定安全的 DAO. 当配置 Shiro 时, 必须指定至少一个 Realm 用来进行身份验证和授权。 Shiro 提供了多种可用的 Realms 来获取安全相关的数据. 例如关系数据库(JDBC), INI 及属性文件等。 可以定义自己 Realm 实现来代表自定义的数据源。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:5:3","tags":null,"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"如何配置在 Spring 中配置使用 Shiro 在 web.xml 中配置 Shiro 的 Filter； 在 Spring 的配置文件中配置 Shiro； 配置自定义 Realm：实现自定义认证和授权； 配置 Shiro 实体类使用的缓存策略； 配置 SecurityManager； 配置保证 Shiro 内部 Bean 声明周期都得到执行的 Lifecycle Bean 后置处理器； 配置AOP 式方法级权限检查； 配置 Shiro Filter ","date":"2022-03-16","objectID":"https://hahaen.github.io/shiro/:6:0","tags":null,"title":"Shiro","uri":"https://hahaen.github.io/shiro/"},{"categories":["java知识"],"content":"对Redis 的了解？ 基于内存也可持久化的数据库，采用单线程，避免了不必要的上下文切换。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:1:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis 一般都有哪些使用场景？ Redis 适合的场景 缓存：减轻 MySQL 的查询压力，提升系统性能； 排行榜：利用 Redis 的 SortSet（有序集合）实现； Session 共享：Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上， 这就会导致用户频繁登陆；采用 Redis 保存 Session 后，无论用户落在那台机器上都能够获取到对应的 Session 信息。 消息队列：除了 Redis 自身的发布/订阅模式，我们也可以利用 List 来实现一个队列机制， 比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的 DB 压力，完全可以用 List 来完成异步解耦； Redis 不适合的场景 数据量太大 数据访问频率非常低的业务 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:2:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis的数据类型？ string(字符串) list(列表) set(集合) hash(哈希) sorted set(有序集合) ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:3:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"讲讲Redis主从复制？ 当启动一个 slave(死里无) node 的时候，它会发送一个 PSYNC 命令给 master node。 如果这是 slave node 初次连接到 master node，那么会触发一次全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件， 同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave， slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中， 接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。 slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:4:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"由于主从延迟导致读取到过期数据怎么处理？ 通过scan命令扫库：当Redis中的key被scan的时候，相当于访问了该key， 同样也会做过期检测，充分发挥Redis惰性删除的策略。 这个方法能大大降低了脏数据读取的概率，但缺点也比较明显，会造成一定的数据库压力，否则影响线上业务的效率。 Redis加入了一个新特性来解决主从不一致导致读取到过期数据问题，增加了key是否过期以及对主从库的判断， 如果key已过期，当前访问的master则返回null；当前访问的是从库，且执行的是只读命令也返回null。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:5:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis主从架构数据会丢失吗，为什么？ 有两种数据丢失的情况： 异步复制导致的数据丢失:因为master -\u003e slave的复制是异步的， 所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了。 脑裂导致的数据丢失: 某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着，此时哨兵可能就会认为master宕机了， 然后开启选举，将其他slave切换成了master。这个时候，集群里就会有两个master，也就是所谓的脑裂。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:6:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"讲讲Redis哨兵模式？ 哨兵主要是用于实现 redis 集群的高可用，哨兵是 redis 集群机构中非常重要的一个组件，他有 集群监控：负责监控 redis master 和 slave 进程是否正常工作。 消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:7:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"讲讲Redis持久化？ 持久化有RDB和AOF两种机制 RDB:是Redis的默认持久化，按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为 dump.rdb。 通过配置文件中的 save 参数来定义快照的周期。 AOF:是将 Redis 执行的每次写命令记录到单独的日志文件中，当重启 Redis 会重新将持久化的日志中文件恢复数据。 AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。 AOF 比 RDB 更安全也更大 RDB 性能比 AOF 好 如果两个都配了优先加载 AOF ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:8:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"怎么保证缓存和数据库数据的一致性？ 设置了合理的键的过期时间 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:9:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis是如何使用的？或者说Redis是如何实现分布式锁的？ 就是我们要用这个分布式锁的话，就是我们要满足几个条件，首先我们要保证他们要有一个互刺性， 在任意时刻呢，只能有一个客户端，他是只能持有这个锁，然后我们也要避免说是不能发生死锁， 就是即使我们只有一个客户端，有他在持有锁的期间内啊，然后崩溃了然后没有主动解锁的话， 也要保证后续的这些客户端呢，他们也是能够持续可以去加锁的，然后我们还要保证的是说他还有一个容错性， 就是我们这个绝大部分的一个Redis，要保证他这个节点正常运行嘛，然后我们客户端就可以加锁跟解锁，那我们加锁和解锁呢， 必须是一个同一个客服端，这样的话客服端自己呢，他是不能把别人的锁给解了啊，差不多就是这样。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:10:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"常见的分布式锁有哪些解决方案？ ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:11:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"基于关系型数据库，如MySQL 基于关系型数据库实现分布式锁，是依赖数据库的唯一性来实现资源锁定，比如主键和唯一索引等。 缺点： 数据库挂掉，会导致业务系统不可用 没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。 只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。 没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。 同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:11:1","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"基于Redis实现 优点： Redis 锁实现简单，理解逻辑简单，性能好，可以支撑高并发的获取、释放锁操作。 缺点： Redis 容易单点故障，集群部署，并不是强一致性的，锁的不够健壮； key 的过期时间设置多少不明确，只能根据实际情况调整； 需要自己不断去尝试获取锁，比较消耗性能。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:11:2","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"基于zookeeper 优点： zookeeper 天生设计定位就是分布式协调，强一致性，锁很健壮。如果获取不到锁， 只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。 缺点： 在高请求高并发下，系统疯狂的加锁释放锁，最后 zookeeper 承受不住这么大的压力可能会存在宕机的风险。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:11:3","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis为什么这么的快？ 因为绝大部分Redis请求，都是我们的内存操作，所以他会非常的快，然后因为我们Redis， 他是基于一个内存的一个数据库，那可以跟我们这种磁盘数据库，可以去做一个对比， 比如说我们的MySQL数据库，想我们的MySQL数据库呢，他就是一个关系型数据库，他主要是用于存放我们一个持久化的一个数据， 然后把我们的数据呢，存放在这个硬盘中，然后读取速度就会比较慢，因为每次请求这种，MySQL数据库的时候， 他其实是存在一个I/O操作，如果我们反复啊，频繁啊，去访问这种数据库的话，会在数据库过程中会花费一个时间嘛， 而且我们反复的访问这种数据库的话，会导致我们这个，数据库的一个负载过高，那我们的Redis是基于内存的嘛， 所以他这种内存型的这种缓存数据库，就是用于存储我们这种使用频繁的数据啊，这样可以减少我们去访问，这种数据库的一种次数， 提升我们的一个运行效率，然后因为他是存在采用这个单线程的嘛，然后就避免了不必要的上下文切换，还有我们的一些竞争条件， 还有个特点，Redis这边是非阻塞的IO，就是我们的IO的一个多路互用，就这些。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:12:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"什么是缓存穿透？怎么解决？ 缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存， 这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 解决办法: 缓存空对象：如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存， 但它的过期时间会很短，最长不超过五分钟。 布隆过滤器：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉， 从而避免了对底层存储系统的查询压力。 缓存空对象带来的问题: 空值做了缓存，意味着缓存中存了更多的键，需要更多的内存空间 缓存和存储的数据会有一段时间窗口的不一致，可能会对业务有一定影响 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:13:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"什么是缓存雪崩？该如何解决？ 如果缓存集中在一段时间内失效，所有的查询都落在数据库上，造成了缓存雪崩。 解决办法： 加锁排队：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。 比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待； 数据预热：可以通过缓存 reload 机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的 key， 设置不同的过期时间，让缓存失效的时间点尽量均匀； 做二级缓存：Cache1 为原始缓存，Cache2 为拷贝缓存，Cache1 失效时，可以访问 Cache2， Cache1 缓存失效时间设置为短期，Cache2 设置为长期。 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:14:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis的过期键的删除策略 Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。 Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。 Redis中同时使用了惰性过期和定期过期两种过期策略。 过期策略通常有以下三种： 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。 定期清楚：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:15:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"为什么要用 Redis 而不用 map/guava 做缓存? 缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的是本地缓存， 最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下， 每个实例都需要各自保存一份缓存，缓存不具有一致性。 使用Redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。 缺点是需要保持Redis或memcached服务的高可用，整个程序架构上较为复杂。 对比: Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了； Redis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了； Redis 可以实现分布式的缓存，Map 只能存在创建它的程序里； Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象； Redis 缓存有过期机制，Map 本身无此功能；Redis 有丰富的 API，Map 就简单太多了； Redis可单独部署，多个项目之间可以共享，本地内存无法共享； Redis有专门的管理工具可以查看缓存数据。 ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:16:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"Redis 常见性能问题和解决方案？ Master 最好不要做任何持久化工作， 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内； 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master \u003c- Slave1 \u003c- Slave2 \u003c- Slave3… ","date":"2022-03-16","objectID":"https://hahaen.github.io/redis/:17:0","tags":null,"title":"Redis","uri":"https://hahaen.github.io/redis/"},{"categories":["java知识"],"content":"什么是反射？ ","date":"2022-03-15","objectID":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/:1:0","tags":null,"title":"反射","uri":"https://hahaen.github.io/%E5%8F%8D%E5%B0%84/"},{"categories":["网络"],"content":"DNS DNS 主要的作用就是将域名 “翻译”成电脑可以理解的 IP 地址， 这个过程叫做 DNS 域名解析。 打个比方，我们登百度的地址的时候，都是敲www.baidu.com，进行登陆，难道你会去敲IP地址登百度？明显，域名容易记忆。 而且，一个域名往往对应多个DNS地址 ","date":"2022-03-14","objectID":"https://hahaen.github.io/dns%E7%9A%84%E5%8E%9F%E7%90%86/:1:0","tags":null,"title":"DNS的原理","uri":"https://hahaen.github.io/dns%E7%9A%84%E5%8E%9F%E7%90%86/"},{"categories":["网络"],"content":"浏览器中输入URL到返回页面的全过程？ 根据域名，进行DNS域名解析； 拿到解析的IP地址，建立TCP连接； 向IP地址，发送HTTP请求； 服务器处理请求； 返回响应结果； 关闭TCP连接； 浏览器解析HTML； 浏览器布局渲染； ","date":"2022-03-14","objectID":"https://hahaen.github.io/dns%E7%9A%84%E5%8E%9F%E7%90%86/:2:0","tags":null,"title":"DNS的原理","uri":"https://hahaen.github.io/dns%E7%9A%84%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"什么是微服务架构? 微服务架构就是将单体的应用程序分成多个应用程序，这多个应用程序就成为微服务， 每个微服务运行在自己的进程中，并使用轻量级的机制通信。 这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。 这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:1:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"为什么需要学习Spring Cloud 首先springcloud基于spingboot的优雅简洁，可还记得我们被无数xml支配的恐惧？ 可还记得springmvc，mybatis错综复杂的配置，有了spingboot，这些东西都不需要了， spingboot好处不再赘诉，springcloud就基于SpringBoot把市场上优秀的服务框架组合起来， 通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理。 什么叫做开箱即用？即使是当年的黄金搭档dubbo+zookeeper下载配置起来也是颇费心神的！ 而springcloud完成这些只需要一个jar的依赖就可以了！ springcloud大多数子模块都是直击痛点，像zuul解决的跨域，fegin解决的负载均衡，hystrix的熔断机制等 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:2:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud 是什么 Spring Cloud是一系列框架的有序集合。 它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发， 如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等， 都可以用Spring Boot的开发风格做到一键启动和部署。 Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来， 通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理， 最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:3:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"SpringCloud的优缺点 优点： 耦合度比较低。不会影响其他模块的开发。 减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。 配置比较简单，基本用注解就能实现，不用使用过多的配置文件。 微服务跨平台的，可以用任何一种语言开发。 每个微服务可以有自己的独立的数据库也有用公共的数据库。 直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。 缺点： 部署比较麻烦，给运维工程师带来一定的麻烦。 针对数据的管理比麻烦，因为微服务可以每个微服务使用一个数据库。 系统集成测试比较麻烦 性能的监控比较麻烦。【最好开发一个大屏监控系统】 总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:4:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"SpringBoot和SpringCloud的区别？ SpringBoot专注于快速方便的开发单个个体微服务。 SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来， 为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务 SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系 SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:5:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"SpringCloud由什么组成 Spring Cloud Eureka：服务注册与发现 Spring Cloud Zuul：服务网关 Spring Cloud Ribbon：客户端负载均衡 Spring Cloud Feign：声明性的Web服务客户端 Spring Cloud Hystrix：断路器 Spring Cloud Config：分布式统一配置管理 等20几个框架，开源一直在更新 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:6:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"使用 Spring Boot 开发分布式微服务时，我们面临什么问题 与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。 服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。 它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。 冗余-分布式系统中的冗余问题。 负载平衡 –负载平衡改善跨多个计算资源的工作负荷， 如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。 性能-问题 由于各种运营开销导致的性能问题。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:7:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud 和dubbo区别? 服务调用方式：dubbo是RPC springcloud Rest Api 注册中心：dubbo 是zookeeper springcloud是eureka，也可以是zookeeper 服务网关，dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关， 作为路由服务器，进行消费者的请求分发,springcloud支持断路器， 与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:8:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Eureka ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:9:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"服务注册和发现是什么意思？Spring Cloud 如何实现？ 当我们开始一个项目时，我们通常在属性文件中进行所有的配置。 随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。 有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。 由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找， 因此无需处理服务地点的任何更改和处理。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:10:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是Eureka Eureka作为SpringCloud的服务注册功能服务器，他是服务注册中心， 系统中的其他服务使用Eureka的客户端将其连接到Eureka Service中，并且保持心跳， 这样工作人员可以通过Eureka Service来监控各个微服务是否运行正常。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:11:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Eureka怎么实现高可用 集群吧，注册多台Eureka，然后把SpringCloud服务互相注册， 客户端从Eureka获取信息时，按照Eureka的顺序来访问。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:12:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是Eureka的自我保护模式 默认情况下，如果Eureka Service在一定时间内没有接收到某个微服务的心跳， Eureka Service会进入自我保护模式，在该模式下Eureka Service会保护服务注册表中的信息， 不在删除注册表中的数据，当网络故障恢复后，Eureka Servic 节点会自动退出自我保护模式 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:13:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"DiscoveryClient的作用 可以从注册中心中根据服务别名获取注册的服务器信息。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:14:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别 ZooKeeper中的节点服务挂了就要选举,在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的， 选举就是改微服务做了集群 Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。 如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的 Eureka本质上是一个工程,而ZooKeeper只是一个进程 Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪 ZooKeeper保证的是CP，Eureka保证的是AP ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:15:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Zuul ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:16:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是网关? 网关相当于一个网络服务架构的入口，所有网络请求必须通过网关转发到具体的服务。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:17:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"网关的作用是什么 统一管理微服务请求，权限控制、负载均衡、路由转发、监控、安全控制黑名单和白名单等 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:18:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是Spring Cloud Zuul（服务网关） Zuul是对SpringCloud提供的成熟对的路由方案，他会根据请求的路径不同， 网关会定位到指定的微服务，并代理请求到不同的微服务接口，他对外隐蔽了微服务的真正接口地址。 三个重要概念：动态路由表，路由定位，反向代理： 动态路由表：Zuul支持Eureka路由，手动配置路由，这俩种都支持自动更新 路由定位：根据请求路径，Zuul有自己的一套定位服务规则以及路由表达式匹配 反向代理：客户端请求到路由网关，网关受理之后，在对目标发送请求，拿到响应之后在 给客户端 它可以和Eureka,Ribbon,Hystrix等组件配合使用 Zuul的应用场景：对外暴露，权限校验，服务聚合，日志审计等 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:19:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"网关与过滤器有什么区别 网关是对所有服务的请求进行分析过滤，过滤器是对单个服务而言。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:20:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"常用网关框架有那些？ Nginx、Zuul、Gateway ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:21:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Zuul与Nginx有什么区别？ Zuul是java语言实现的，主要为java服务提供网关服务，尤其在微服务架构中可以更加灵活的对网关进行操作。 Nginx是使用C语言实现，性能高于Zuul，但是实现自定义操作需要熟悉lua语言， 对程序员要求较高，可以使用Nginx做Zuul集群。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:22:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"既然Nginx可以实现网关？为什么还需要使用Zuul框架 Zuul是SpringCloud集成的网关，使用Java语言编写，可以对SpringCloud架构提供更灵活的服务。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:23:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"如何设计一套API接口 考虑到API接口的分类可以将API接口分为开发API接口和内网API接口，内网API接口用于局域网， 为内部服务器提供服务。开放API接口用于对外部合作单位提供接口调用， 需要遵循Oauth2.0权限认证协议。同时还需要考虑安全性、幂等性等问题。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:24:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"ZuulFilter常用有那些方法 Run()：过滤器的具体业务逻辑 shouldFilter()：判断过滤器是否有效 filterOrder()：过滤器执行顺序 filterType()：过滤器拦截位置 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:25:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"如何实现动态Zuul网关路由转发 通过path配置拦截请求，通过ServiceId到配置中心获取转发的服务列表， Zuul内部使用Ribbon实现本地负载均衡和转发。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:26:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Zuul网关如何搭建集群 使用Nginx的upstream设置Zuul服务集群，通过location拦截请求并转发到upstream， 默认使用轮询机制对Zuul集群发送请求。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:27:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Ribbon ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:28:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"负载平衡的意义什么？ 简单来说： 先将集群，集群就是把一个的事情交给多个人去做，假如要做1000个产品给一个人做要10天， 我叫10个人做就是一天，这就是集群，负载均衡的话就是用来控制集群， 他把做的最多的人让他慢慢做休息会，把做的最少的人让他加量让他做多点。 在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接， 中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用， 最大化吞吐量，最小化响应时间并避免任何单一资源的过载。 使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。 负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:29:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Ribbon是什么？ Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法 Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。 简单的说，就是在配置文件中列出后面所有的机器， Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。 我们也很容易使用Ribbon实现自定义的负载均衡算法。（有点类似Nginx） ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:30:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Nginx与Ribbon的区别 Nginx是反向代理同时可以实现负载均衡， nginx拦截客户端请求采用负载均衡策略根据upstream配置进行转发，相当于请求通过nginx服务器进行转发。 Ribbon是客户端负载均衡，从注册中心读取目标服务器信息， 然后客户端采用轮询策略对服务直接访问，全程在客户端操作。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:31:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Ribbon底层实现原理 Ribbon使用discoveryClient从注册中心读取目标服务信息，对同一接口请求进行计数， 使用%取余算法获取目标服务集群索引，返回获取到的目标服务信息。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:32:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"@LoadBalanced注解的作用 开启客户端负载均衡。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:33:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Hystrix ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:34:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是断路器 当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应） 断路器有三种状态: 打开状态：一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象, 断路器完全打开 那么下次请求就不会请求到该服务 半开状态：短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭 关闭状态：当服务一直处于正常状态 能正常调用 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:35:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是 Hystrix？ 在分布式系统，我们一定会依赖各种服务，那么这些个服务一定会出现失败的情况，就会导致雪崩 Hystrix就是这样的一个工具，防雪崩利器，它具有服务降级，服务熔断，服务隔离，监控等一些防止雪崩的技术。 Hystrix有四种防雪崩方式: 服务降级：接口调用失败就调用本地的方法返回一个空 服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息 服务隔离：隔离服务之间相互影响 服务监控：在服务发生调用时,会将每秒请求数、成功请求数等运行指标记录下来。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:36:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"服务雪崩效应 雪崩效应是在大型互联网项目中，当某个服务发生宕机时，调用这个服务的其他服务也会发生宕机， 大型项目的微服务之间的调用是互通的，这样就会将服务的不可用逐步扩大到各个其他服务中， 从而使整个项目的服务宕机崩溃.发生雪崩效应的原因有以下几点 单个服务的代码存在bug. 请求访问量激增导致服务发生崩溃(如大型商城的枪红包，秒杀功能) 服务器的硬件故障也会导致部分服务不可用. ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:37:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"在微服务中，如何保护服务? 一般使用使用Hystrix框架，实现服务隔离来避免出现服务的雪崩效应，从而达到保护服务的效果。 当微服务中，高并发的数据库访问量导致服务线程阻塞，使单个服务宕机，服务的不可用会蔓延到其他服务， 引起整体服务灾难性后果，使用服务降级能有效为不同的服务分配资源,一旦服务不可用则返回友好提示， 不占用其他服务资源，从而避免单个服务崩溃引发整体服务的不可用. ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:38:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"服务雪崩效应产生的原因 因为Tomcat默认情况下只有一个线程池来维护客户端发送的所有的请求， 这时候某一接口在某一时刻被大量访问就会占据tomcat线程池中的所有线程， 其他请求处于等待状态，无法连接到服务接口。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:39:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"谈谈服务降级、熔断、服务隔离 服务降级：当客户端请求服务器端的时候，防止客户端一直等待，不会处理业务逻辑代码，直接返回一个友好的提示给客户端。 服务熔断是在服务降级的基础上更直接的一种保护方式， 当在一个统计时间范围内的请求失败数量达到设定值（requestVolumeThreshold）或当前的请求错误率达到设定的错误率阈值（errorThresholdPercentage）时开启断路， 之后的请求直接走fallback方法，在设定时间（sleepWindowInMilliseconds）后尝试恢复。 服务隔离就是Hystrix为隔离的服务开启一个独立的线程池，这样在高并发的情况下不会影响其他服务。 服务隔离有线程池和信号量两种实现方式，一般使用线程池方式。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:40:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"服务降级底层是如何实现的？ Hystrix实现服务降级的功能是通过重写HystrixCommand中的getFallback()方法 当Hystrix的run方法或construct执行发生错误时转而执行getFallback()方法。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:41:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Feign ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:42:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是Feign？ Feign 是一个声明web服务客户端，这使得编写web服务客户端更容易 他将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了， 直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:43:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"SpringCloud有几种调用接口方式 Feign RestTemplate ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:44:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Ribbon和Feign调用服务的区别 调用方式同：Ribbon需要我们自己构建Http请求，模拟Http请求然后通过RestTemplate发给其他服务，步骤相当繁琐 而Feign则是在Ribbon的基础上进行了一次改进，采用接口的形式， 将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了， 直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:45:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Bus ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:46:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是 Spring Cloud Bus？ Spring Cloud Bus就像一个分布式执行器，用于扩展的Spring Boot应用程序的配置文件，但也可以用作应用程序之间的通信通道。 Spring Cloud Bus 不能单独完成通信，需要配合MQ支持 Spring Cloud Bus一般是配合Spring Cloud Config做配置中心的 Springcloud config实时刷新也必须采用SpringCloud Bus消息总线 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:47:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Config ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:48:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是Spring Cloud Config? Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持， 可以方便的对微服务各个环境下的配置进行集中式管理。Spring Cloud Config分为Config Server和Config Client两部分。 Config Server负责读取配置文件，并且暴露Http API接口，Config Client通过调用Config Server的接口来读取配置文件。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:49:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"分布式配置中心有那些框架？ Apollo、zookeeper、springcloud config。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:50:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"分布式配置中心的作用？ 动态变更项目配置信息而不必重新部署项目。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:51:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"SpringCloud Config 可以实现实时刷新吗？ springcloud config实时刷新采用SpringCloud Bus消息总线。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:52:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Gateway ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:53:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"什么是Spring Cloud Gateway? Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。 网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。 使用了一个RouteLocatorBuilder的bean去创建路由， 除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思， 顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:54:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"SpringCloud主要项目 Spring Cloud的子项目，大致可分成两类 一类是对现有成熟框架\"Spring Boot化\"的封装和抽象，也是数量最多的项目 第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:55:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Config Config能够管理所有微服务的配置文件 集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:56:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Netflix(重点，这些组件用的最多) Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。 Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制； Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略； Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力； Feign：基于Ribbon和Hystrix的声明式服务调用组件； Zuul：API网关组件，对请求提供路由及过滤功能。 我觉得SpringCloud的福音是Netflix，他把人家的组件都搬来进行封装了，使开发者能快速简单安全的使用 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:57:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Bus 用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置信息。 简单来说就是修改了配置文件，发送一次请求，所有客户端便会重新读取配置文件。 需要利用中间插件MQ ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:58:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Consul Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。 与其它分布式服务注册与发现的方案，Consul 的方案更“一站式”， 内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案， 不再需要依赖其它工具（比如 ZooKeeper 等）。使用起来也较为简单。Consul 使用 Go 语言编写， 因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件， 方便部署，与 Docker 等轻量级容器可无缝配合。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:59:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Security 安全工具包，他可以对 对Zuul代理中的负载均衡从前端到后端服务中获取SSO令牌 资源服务器之间的中继令牌 使Feign客户端表现得像OAuth2RestTemplate（获取令牌等）的拦截器 在Zuul代理中配置下游身份验证 Spring Cloud Security提供了一组原语，用于构建安全的应用程序和服务，而且操作简便。 可以在外部（或集中）进行大量配置的声明性模型有助于实现大型协作的远程组件系统， 通常具有中央身份管理服务。它也非常易于在Cloud Foundry等服务平台中使用。 在Spring Boot和Spring Security OAuth2的基础上，可以快速创建实现常见模式的系统， 如单点登录，令牌中继和令牌交换。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:60:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Sleuth 在微服务中，通常根据业务模块分服务，项目中前端发起一个请求，后端可能跨几个服务调用才能完成这个请求。 如果系统越来越庞大，服务之间的调用与被调用关系就会变得很复杂， 假如一个请求中需要跨几个服务调用，其中一个服务由于网络延迟等原因挂掉了， 那么这时候我们需要分析具体哪一个服务出问题了就会显得很困难。 Spring Cloud Sleuth服务链路跟踪功能就可以帮助我们快速的发现错误根源以及监控分析每条请求链路上的性能等等。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:61:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Stream 轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:62:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Task Spring Cloud Task的目标是为Spring Boot应用程序提供创建短运行期微服务的功能。 在Spring Cloud Task中，我们可以灵活地动态运行任何任务， 按需分配资源并在任务完成后检索结果。Tasks是Spring Cloud Data Flow中的一个基础项目， 允许用户将几乎任何Spring Boot应用程序作为一个短期任务执行。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:63:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Zookeeper SpringCloud支持三种注册方式Eureka， Consul(go语言编写)，zookeeper Spring Cloud Zookeeper是基于Apache Zookeeper的服务治理组件。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:64:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud Gateway Spring cloud gateway是spring官方基于Spring 5.0、Spring Boot2.0和Project Reactor等技术开发的网关， Spring Cloud Gateway旨在为微服务架构提供简单、有效和统一的API路由管理方式， Spring Cloud Gateway作为Spring Cloud生态系统中的网关， 目标是替代Netflix Zuul，其不仅提供统一的路由方式， 并且还基于Filer链的方式提供了网关基本的功能， 例如：安全、监控/埋点、限流等。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:65:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["java知识"],"content":"Spring Cloud OpenFeign Feign是一个声明性的Web服务客户端。它使编写Web服务客户端变得更容易。 要使用Feign，我们可以将调用的服务方法定义成抽象方法保存在本地添加一点点注解就可以了， 不需要自己构建Http请求了，直接调用接口就行了， 不过要注意，调用方法要和本地抽象方法的签名完全一致。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/springcloud/:66:0","tags":null,"title":"SpringCloud","uri":"https://hahaen.github.io/springcloud/"},{"categories":["MySQL知识"],"content":"万能密码 原验证登陆语句: SELECT*FROMadminWHEREUsername='\".$username.\"'ANDPassword='\".md5($password).\"' 输入 1′ or 1=1 or ‘1’=’1万能密码语句变为: SELECT*FROMadminWHEREUsername='1'OR1=1OR'1'='1'ANDPassword='EDFKGMZDFSDFDSFRRQWERRFGGG' 即得到优先级关系：or\u003cand\u003cnot，同一优先级默认从左往右计算。 上面’1’=’1’ AND Password=’EDFKGMZDFSDFDSFRRQWERRFGGG’先计算肯定返回false,因为密码是我们乱输入的。(此处是假) Username=’1’ 返回假,没有用户名是1(此处是假) 1=1返回真(此处是真) 以上的结果是: 假 or 真 or 假 返回真。验证通过。 ","date":"2022-03-14","objectID":"https://hahaen.github.io/sql%E6%B3%A8%E5%85%A5/:1:0","tags":null,"title":"Sql注入","uri":"https://hahaen.github.io/sql%E6%B3%A8%E5%85%A5/"},{"categories":["java知识"],"content":"SpringBoot与SpringCloud的区别 SpringBoot是快速开发的Spring框架 SpringCloud是完整的微服务框架，SpringCloud依赖于SpringBoot。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:1:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot有哪些优点？ 容易上手，提升开发效率，为 Spring 开发提供一个更快、更简单的开发框架。 开箱即用，远离繁琐的配置。 提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。 SpringBoot总结就是使编码变简单、配置变简单、部署变简单、监控变简单等等 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:2:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？ 启动类上面的注解是@SpringBootApplication， 它也是Spring Boot 的核心注解，主要组合包含了以下 3 个注解： @SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。 @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 例如：java 如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。 @ComponentScan：Spring组件扫描。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:3:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot常用注解？ @SpringBootApplication 启动类 @RestController 控制器,@Controller和@ResponseBody的合集 @RequestMapping(锐快四特) 负责URL的映射 @PathVariable(怕死锐了要不) 获取URL上的参数 @Service 修饰service层 @Inject(印姐可特) @AutoWired(奥头为要) 自动导入依赖 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:4:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot Starter的工作原理 在sprinBoot启动时由@SpringBootApplication注解会自动去maven中读取每个starter中的spring.factories文件, 该文件里配置了所有需要被创建spring容器中的bean，并且进行自动配置把bean注入SpringContext中 //（SpringContext是Spring的配置文件） ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:5:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？ 配置变更 JDK 版本升级 第三方类库升级 响应式 Spring 编程支持 HTTP/2 支持 配置属性绑定 更多改进与加强 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:6:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot支持什么前端模板? thymeleaf freemarker jsp，官方不推荐JSP会有限制 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:7:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot的缺点? 不用自己做的配置，报错时很难定位。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:8:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"运行 Spring Boot 有哪几种方式？ 打包用命令或者放到容器中运行 用 Maven/ Gradle 插件运行 直接执行 main 方法运行 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:9:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 需要独立的容器运行吗？ 可以不需要 内置了 Tomcat/ Jetty 等容器。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:10:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"开启 Spring Boot 特性有哪几种方式？ 继承spring-boot-starter-parent项目 导入spring-boot-dependencies项目依赖 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:11:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot 实现热部署有哪几种方式？ 热部署就是可以不用重新运行SpringBoot项目可以实现操作后台代码自动更新到以运行的项目中 主要有两种方式： Spring Loaded Spring-boot-devtools ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:12:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot事物的使用 首先使用注解EnableTransactionManagement开启事物之后，然后在Service方法上添加注解Transactional便可。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:13:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Async异步调用方法 需要在方法上使用@Async注解即可实现方法的异步调用。 注意：需要在启动类加入@EnableAsync使异步调用@Async注解生效。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:14:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"如何在 Spring Boot 启动的时候运行一些特定的代码？ 可以实现接口 ApplicationRunner 或者 CommandLineRunner 这两个接口实现方式一样，它们都只提供了一个 run 方法 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:15:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 有哪几种读取配置的方式？ Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationPropertie注解来绑定变量 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:16:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"什么是 JavaConfig？ Spring JavaConfig 是 Spring 社区的产品，Spring 3.0引入了他， 它提供了配置 Spring IOC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于： 面向对象的配置。由于配置被定义为 JavaConfig 中的类， 因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。 减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。 但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。 从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。 类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。 由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。 常用的Java config： @Configuration：在类上打上写下此注解，表示这个类是配置类 @ComponentScan：在配置类上添加 @ComponentScan 注解。 该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 \u003ccontext:component-scan \u003e。 @Bean：bean的注入：相当于以前的\u003c bean id=“objectMapper” class=“org.codehaus.jackson.map.ObjectMapper” /\u003e @EnableWebMvc：相当于xml的\u003cmvc:annotation-driven \u003e @ImportResource： 相当于xml的 \u003c import resource=“applicationContext-cache.xml”\u003e ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:17:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot的自动配置原理是什么? 主要是Spring Boot的启动类上的核心注解SpringBootApplication注解主配置类， 有了这个主配置类启动时就会为SpringBoot开启一个@EnableAutoConfiguration注解自动配置功能。 有了这个EnableAutoConfiguration的话就会： 从配置文件META_INF/Spring.factories加载可能用到的自动配置类 去重，并将exclude和excludeName属性携带的类排除 过滤，将满足条件（@Conditional）的自动配置类返回 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:18:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"你如何理解 Spring Boot 配置加载顺序？ 在 Spring Boot 里面，可以使用以下几种方式来加载配置。 properties文件； YAML文件； 系统环境变量； 命令行参数； ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:19:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"什么是 YAML？ YAML 是一种人类可读的数据序列化语言。 它通常用于配置文件。 与属性文件相比，如果我们想要在配置文件中添加复杂的属性， YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:20:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"YAML 配置的优势在哪里 ? YAML 现在可以算是非常流行的一种配置文件格式了， 无论是前端还是后端，都可以见到 YAML 配置。 那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？ 配置有序，在一些特殊的场景下，配置有序很关键 简洁明了，他还支持数组，数组中的元素可以是基本数据类型也可以是对象 相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:21:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 是否可以使用 XML 配置 ? Spring Boot 推荐使用 Java 配置而非 XML 配置， 但是 Spring Boot 中也可以使用 XML 配置， 通过 @ImportResource 注解可以引入一个 XML 配置。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:22:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ? 单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件， 但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。 spring boot 核心的两个配置文件： bootstrap (. yml 或者 . properties)： boostrap 由父 ApplicationContext 加载的， 比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。 一般来说我们在 Spring Cloud 配置就会使用这个文件。 且 boostrap 里面的属性不能被覆盖； application (. yml 或者 . properties)： 由ApplicatonContext 加载， 用于 spring boot 项目的自动化配置。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:23:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"什么是 Spring Profiles？ 在项目的开发中，有些配置文件在开发、测试或者生产等不同环境中可能是不同的， 例如数据库连接、redis的配置等等。 那我们如何在不同环境中自动实现配置的切换呢？ Spring给我们提供了profiles机制给我们提供的就是来回切换配置文件的功能 Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。 因此，当应用程序在开发中运行时，只有某些 bean 可以加载， 而在 PRODUCTION中，某些其他 bean 可以加载。 假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。 这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:24:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot多数据源拆分的思路？ 先在properties配置文件中配置两个数据源，创建分包mapper， 使用@ConfigurationProperties读取properties中的配置，使用@MapperScan注册到对应的mapper包中 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:25:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot多数据源事务如何管理 第一种方式是在service层的@TransactionManager中使用transactionManager指定DataSourceConfig中配置的事务 第二种是使用jta-atomikos实现分布式事务管理 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:26:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"保护 Spring Boot 应用有哪些方法？ 在生产中使用HTTPS 使用Snyk检查你的依赖关系 升级到最新版本 启用CSRF保护 使用内容安全策略防止XSS攻击 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:27:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"如何实现 Spring Boot 应用程序的安全性？ 为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项， 并且必须添加安全配置。它只需要很少的代码。 配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:28:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"比较一下 Spring Security 和 Shiro 各自的优缺点 ? 由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ， 使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口， 所以，如果是 Spring Boot 项目，一般选择 Spring Security 。 当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。 Shiro 和 Spring Security 相比，主要有如下一些特点： Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架 Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单 Spring Security 功能强大；Shiro 功能简单 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:29:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 中如何解决跨域问题 ? 跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求， 在 RESTful 风格的应用中，就显得非常鸡肋， 因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。 这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中， 就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ， 现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。 @Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"/**\") .allowedOrigins(\"*\") .allowCredentials(true) .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\") .maxAge(3600); } } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:30:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 中的监视器是什么？ Spring boot actuator 是 spring 启动框架中的重要功能之一。 Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。 有几个指标必须在生产环境中进行检查和监控。 即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。 监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:31:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"如何使用 Spring Boot 实现全局异常处理？ Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:32:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"我们如何监视所有 Spring Boot 微服务？ Spring Boot 提供监视器端点以监控各个微服务的度量。 这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。 但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。 想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。 为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI， 使我们能够可视化多个应用程序的度量。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:33:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot性能如何优化? 如果项目比较大，类比较多，不使用@SpringBootApplication，采用@Compoment指定扫包范围 在项目启动时设置JVM初始内存和最大内存相同 将springboot内置服务器由tomcat设置为undertow ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:34:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？ 这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。 Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。 Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。 开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。 这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。 这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。 它还提供 H2 数据库控制台以更好地测试应用程序。 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:35:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot微服务中如何实现 session 共享 ? 在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上， 各自的 session 被从物理空间上隔离开了， 但是经常，我们需要在不同微服务之间共享 session ， 常见的方案就是 Spring Session + Redis 来实现 session 共享。 将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时， 都去操作 Redis 上的 session 。这样就实现了 session 共享， Spring Session 基于 Spring 中的代理过滤器实现， 使得 session 的同步操作对开发人员而言是透明的，非常简便。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:36:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"您使用了哪些 starter maven 依赖项？ 使用了下面的一些依赖项 spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持 spring-boot-starter-data-jpa 数据库支持 spring-boot-starter-data-redis redis数据库支持 spring-boot-starter-data-solr solr支持 mybatis-spring-boot-starter 第三方的mybatis集成starter ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:37:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 中的 starter 到底是什么 ? 首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。 首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ， 在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的）， 然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置， 然后通过类型安全的属性(spring.factories)注入将这些配置属性注入进来， 新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。 当然，开发者也可以自定义 Starter ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:38:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 中如何实现定时任务 ? 在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解， 另一个则是使用第三方框架 Quartz。 使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:39:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"spring-boot-starter-parent 有什么用 ? 总结就是打包用的 我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的， 这个 parent 就是 spring-boot-starter-parent ， spring-boot-starter-parent 主要有如下作用： 定义了 Java 编译版本为 1.8 。 使用 UTF-8 格式编码。 继承自 spring-boot-dependencies，这个里边定义了依赖的版本， 也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。 执行打包操作的配置。 自动化的资源过滤。 自动化的插件配置。 针对 application.properties 和 application.yml 的资源过滤， 包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:40:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringBoot如何实现打包 进入项目目录在控制台输入mvn clean package，clean是清空已存在的项目包，package进行打包 或者点击左边选项栏中的Mavne，先点击clean在点击package ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:41:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"Spring Boot 打成的 jar 和普通的 jar 有什么区别 ? Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行， 这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。 Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。 普通的 jar 包，解压后直接就是包名，包里就是我们的代码， 而 Spring Boot 打包成的可执行 jar 解压后，在 \\BOOT-INF\\classes 目录下才是我们的代码， 因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置， 将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springboot/:42:0","tags":null,"title":"SpringBoot","uri":"https://hahaen.github.io/springboot/"},{"categories":["java知识"],"content":"SpringMVC的核心是什么？ 它的一个核心就是我们的控制反转，和我们的面向切面。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:1:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"什么是MVC模式？ MVC的全名是Model View Controller 是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范。 它是用一种业务逻辑、数据与界面显示分离的方法来组织代码，将众多的业务逻辑聚集到一个部件里面， 在需要改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，达到减少编码的时间。 M即model模型是指模型表示业务规则。 在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的， 模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。 V即View视图是指用户看到并与之交互的界面。 比如由html元素组成的网页界面，或者软件的客户端界面。 MVC的好处之一在于它能为应用程序处理很多不同的视图。 在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。 C即controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求， 控制器本身不输出任何东西和做任何处理。 它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:2:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC的执行流程？ 请求处理流程就是，首先我们的用户，去发送请求到我们的一个前端控制器，然后我们的前端控制器呢，会根据我们请求信息， 比如说我们的URL，来去决定说到底是哪个页面的控制去进行处理，然后并把我们这个处理委托给他嘛， 我们以前的一个控制器的，一个控制逻辑部分嘛，然后还有我们的一个页面控制器， 当他接受到这个请求了之后，然后进行一些功能处理，然后我们首先我们需要去收集和绑定请求参数到一个对象， 然后去进行一个验证，再把这个命令对象委托给我们的业务对象，去进行我们的一个处理， 然后我们处理完毕的时候呢，返回一个我们的ModelAndView嘛，就是我们的数据模型跟视图， 然后前端控制器呢，回收我们的控制权，然后去根据我们的一个返回的逻辑，视图名嘛， 然后再去选择相对应的一个视图进行渲染，再把我们的一个模型数据呢，传入到我们这个，以便我们视图可以去渲染， 然后前端控制器再次回收我们的控制权，然后再去响应，返回给我们的用户。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:3:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC有哪些优点？ SpringMVC本身是与Spring框架结合而成的，它同时拥有Spring的优点(例如依赖注入DI和切面编程AOP等)。 SpringMVc提供强大的约定大于配置的契约式编程支持，即提供一种软件设计范式， 减少软件开发人员做决定的次数，开发人员仅需规定应用中不符合约定的部分。 支持灵活的URL到页面控制器的映射。 可以方便地与其他视图技术(JSP、FreeMarker等)进行整合。 由于SpringMVC的模型数据往往是放置在Map数据结构中的，因此其可以很方便地被其他框架引用。 拥有十分简洁的异常处理机制。 可以十分灵活地实现数据验证、格式化和数据绑定机制，可以使用任意对象进行数据绑定操作。 支持RestFul风格。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:4:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"Spring MVC的主要组件？ 前端控制器：其作用是接收用户请求，然后给用户反馈结果。 它的作用相当于一个转发器或中央处理器，控制整个流程的执行， 对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。 处理器映射器：其作用是根据请求的URL路径，通过注解或者XML配置，寻找匹配的处理器信息。 处理器适配器：其作用是根据映射器处理器找到的处理器信息，按照特定规则执行相关的处理器（Handler）。 处理器：其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至ModelAndView对象中。 视图解析器：其作用是进行解析操作， 通过ModelAndView对象中的View信息将逻辑视图名解析成真正的视图View（如通过一个JSP路径返回一个真正的JSP页面）。 视图：View是一个接口，实现类支持不同的View类型（JSP、FreeMarker、Excel等）。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:5:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC和Struts2的区别有哪些? SpringMVC的入口是一个Servlet，也就是前端控制器(DispatcherServlet)， 而Struts2的入口是一个Filter (StrutsPrepareAndExecuteFilter)。 SpringMVC是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参， 可以设计为单例或多例(建议单例)。struts2是基于类开发，请求参数传递到类的成员属性，只能设计为多例。 SpringMVC通过参数解析器将request请求内容解析，并给方法形参赋值， 将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用JSTL。Struts2采用值栈存储请求和响应的数据，通过OGNL存取数据。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:6:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC怎么样设定重定向和请求转发？ ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:7:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"请求转发与重定向的区别 请求转发在服务器端完成的；重定向是在客户端完成的。 请求转发的速度快；重定向速度慢。 请求转发的是同一次请求；重定向是两次不同请求。 请求转发不会执行转发后的代码；重定向会执行重定向之后的代码。 请求转发地址栏没有变化；重定向地址栏有变化。 请求转发必须是在同一台服务器下完成；重定向可以在不同的服务器下完成。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:7:1","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC设定请求转发 在返回值前面加\"forward:\" @RequestParam(\"/login\") public String redirect(User user){ if{ //登录成功... }else{ //登录失败，转发到登录页面 return \"forward:tologin\"; } } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:7:2","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC设定重定向 在返回值前面加\"redirect:\"。例如我们在登录的时候，登录失败会重定向到登录页面。 @RequestParam(\"/login\") public String redirect(User user){ if{ //登录成功... }else{ //登录失败，重定向到登录页面 return \"redirect:tologin\"; } } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:7:3","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？ Controller是单例模式，在多线程访问的时候可能产生线程安全问题，不要使用同步，会影响程序性能。 解决方案是在控制器里面不能编写成员属性。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:8:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC常用的注解有哪些？ ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@Controller @Controller用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象。 处理器适配器将会扫描使用了该注解的类的方法， 并检测该方法是否使用了@RequestMapping注解。 @Controller只是定义了一个控制器类， 而使用@RequestMapping注解的方法才是真正处理请求的处理器。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:1","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@RequsestMapping @RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 返回值会通过视图解析器解析为实际的物理视图， 对于 InternalResourceViewResolver 视图解析器， 通过 prefix + returnValue + suffix 这样的方式得到实际的物理视图， 然后做转发操作。 \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/jsp/\"/\u003e \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e \u003c/bean\u003e @RequsestMapping有如下6个属性 value：指定请求的实际地址。 method：指定请求的method类型， GET、POST、PUT、DELETE等。 consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html。 produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； params：指定request中必须包含某些参数值是，才让该方法处理。 headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:2","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@ResponseBody @ResponseBody把Java对象转化为json对象，这种方式用于Ajax异步请求， 返回的不是一个页面而是JSON格式的数据。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:3","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@Valid 标志参数被Hibernate-Validator校验框架校验。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:4","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@PathVariable @PathVariable用于接收uri地址传过来的参数，Url中可以通过一个或多个{Xxx}占位符映射， 通过@PathVariable可以绑定占位符参数到方法参数中，在RestFul接口风格中经常使用。 例如：请求URL：http://localhost/user/21/张三/query (Long类型可以根据需求改变为String或int，SpringMVC会自动做转换) @RequestMapping(\"/user/{userId}/{userName}/query\") public User query(@PathVariable(\"userId\") Long userId, @PathVariable(\"userName\") String userName){ ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:5","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@RequestParam @RequestParam用于将请求参数映射到控制器方法的形参上，有如下三个属性 value：参数名。 required：是否必需，默认为true，表示请求参数中必须包含该参数，如果不包含抛出异常。 defaultValue：默认参数值，如果设置了该值自动将required设置为false， 如果参数中没有包含该参数则使用默认值。 示例：@RequestParam(value = “pageNum”, required = false, defaultValue = “1”) ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:6","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@ControllerAdvice @ControllerAdvice标识一个类是全局异常处理类。 @ControllerAdvice public class ControllerTest { //全局异常处理类 } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:7","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@ExceptionHandler @ExceptionHandler标识一个方法为全局异常处理的方法。 @ExceptionHandler public void ExceptionHandler(){ //全局异常处理逻辑... } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:9:8","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？ 一般使用@Controller注解标识控制器。 也可以使用@RestController注解替代@Controller注解， @RestController相当于@ResponseBody＋@Controller， 表示控制器中所有的方法都返回JSON格式数据，一般不使用其他注解标识控制器。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:10:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"如果在拦截请求中，想拦截get方式提交的方法,怎么配置？ 可以在@RequestMapping注解里面加上method=RequestMethod.GET。 @RequestMapping(value=\"/toLogin\",method = RequestMethod.GET) public ModelAndView toLogin(){} 可以使用@GetMapping注解。 @GetMapping(value=\"/toLogin\") public ModelAndView toLogin(){} ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:11:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"怎样在控制器方法里面得到request或者session？ 直接在控制器方法的形参中声明request，session，SpringMvc就会自动把它们注入。 @RequestMapping(\"/login\") public ModelAndView login(HttpServletRequest request, HttpSession session){ } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:12:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"如果想在拦截的方法里面得到从前台传入的参数,怎么得到？ 直接在控制器方法的形参里面声明这个参数就可以，但名字必须和传过来的参数名称一样，否则参数映射失败。 下面方法形参中的userId，就会接收从前端传来参数名称为userId的值。 @RequestMapping(\"/deleteUser\") public void deleteUser(Long userId){ //删除用户操作... } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:13:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"前台传入多个参数,并且这些参数都是一个对象的属性,怎么进行参数绑定？ 直接在控制器方法的形参里面声明这个参数就可以，SpringMvc就会自动会请求参数赋值到这个对象的属性中。 下面方法形参中的user用来接收从前端传来的多个参数，参数名称需要和User实体类属性名称一致。 @RequestMapping(\"/saveUser\") public void saveUser(User user){ //保存用户操作... } @Data public class User { private Long userId; private String username; private String password; //... } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:14:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC用什么对象从后台向前台传递数据的？ 使用Map、Model和ModelMap的方式，这种方式存储的数据是在request域中 @RequestMapping(\"/getUser\") public String getUser(Map\u003cString,Object\u003e map,Model model,ModelMap modelMap){ //1.放在map里 map.put(\"name\", \"xq\"); //2.放在model里，一般是使用这个 model.addAttribute(\"habbit\", \"Play\"); //3.放在modelMap中 modelMap.addAttribute(\"city\", \"gd\"); modelMap.put(\"gender\", \"male\"); return \"userDetail\"; } 使用request的方式 @RequestMapping(\"/getUser\") public String getUser(Map\u003cString,Object\u003e map,Model model,ModelMap modelMap,HttpServletRequest request){ //放在request里 request.setAttribute(\"user\", userService.getUser()); return \"userDetail\"; } 使用ModelAndView @RequestMapping(\"/getUser\") public ModelAndView getUser(ModelAndView modelAndView) { mav.addObject(\"user\", userService.getUser()); mav.setViewName(\"userDetail\"); return modelAndView; } ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:15:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"怎么样把ModelMap里面的数据放入session里面？ 在类上添加@SessionAttributes注解将指定的Model数据存储到session中。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:16:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@SessionAttributes 默认情况下Spring MVC将模型中的数据存储到request域中。 当一个请求结束后，数据就失效了。如果要跨页面使用。 那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中。 @SessionAttributes只能定义在Class,interface enum上， 作用是将指定的Model中的键值对添加至session中，方便在一个会话中使用。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:16:1","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"@SessionAttributes参数 names：这是一个字符串数组。里面应写需要存储到session中数据的名称。 types：根据指定参数的类型，将模型中对应类型的参数存储到session中。 value：其实和上面的names是一样的。 @SessionAttributes(value={\"names\"},types={Integer.class}) @Controller public class session{ @RequestMapping(\"/session\") public String session(Model model){ model.addAttributes(\"names\", Arrays.asList(\"caoyc\",\"zhh\",\"cjx\")); model.addAttributes(\"age\", 22); return \"/session\"; } } 在类上添加@SessionAttributes注解，并指定将names名称的Model数据存储到session域中， 以及将Integer类型的Model数据存储到session域中。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:16:2","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"SpringMVC中有个类把视图和数据都合并的一起的,叫什么？ 它就是ModelAndView。 使用ModelAndView类存储处理完后的结果数据，以及显示该数据的视图。 从名字上看ModelAndView中的Model代表模型，View代表视图，从名字看就很好地解释了该类的作用。 Controller处理器调用模型层处理完用户请求后，把结果数据存储在该类的model属性中， 把要返回的视图信息存储在该类的view属性中，然后把ModelAndView返回给前端控制器。 前端控制器通过调用配置文件中定义的视图解析器，对该对象进行解析，最后把结果数据显示在指定的页面上。 返回指定页面: ModelAndView构造方法可以指定返回的页面名称。 也可以通过setViewName()方法跳转到指定的页面 。 返回所需数值: 使用addObject()设置需要返回的值， addObject()有几个不同参数的方法，可以默认和指定返回对象的名字。 ","date":"2022-03-12","objectID":"https://hahaen.github.io/springmvc/:17:0","tags":null,"title":"SpringMVC","uri":"https://hahaen.github.io/springmvc/"},{"categories":["java知识"],"content":"二叉树遍历 前序遍历：根 —\u003e 左 —\u003e 右 中序遍历：左—\u003e 根 —\u003e 右 后序遍历：左 —\u003e 右 —\u003e 根 ","date":"2022-03-12","objectID":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/:1:0","tags":null,"title":"树","uri":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"categories":["java知识"],"content":"前序遍历 ","date":"2022-03-12","objectID":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/:1:1","tags":null,"title":"树","uri":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"categories":["java知识"],"content":"中序遍历 ","date":"2022-03-12","objectID":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/:1:2","tags":null,"title":"树","uri":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"categories":["java知识"],"content":"后序遍历 ","date":"2022-03-12","objectID":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/:1:3","tags":null,"title":"树","uri":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"categories":["java知识"],"content":"层序遍历 ","date":"2022-03-12","objectID":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/:1:4","tags":null,"title":"树","uri":"https://hahaen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"categories":["java知识"],"content":"复杂度 ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"冒泡排序 冒泡排序 基本原理： 对于给定的n个记录，从第一个记录开始依次对相邻的两个记录进行比较， 当前面的记录大于后面的记录时，交换位置， 进行一轮比较和换位后，n个记录中的最大记录将位于第n位； 然后对前(n-1)个记录进行第二轮比较；重复该过程直到进行比较的记录只剩下一个为止。 /** * @className: BubbleSort * @description: 冒泡排序 * @author: hahaen **/ public class BubbleSort { public static void main(String[] args) { int[] arr = {1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22}; BubbleSort.bubbleSort(arr); for (int i : arr) { System.out.print(i + \",\"); } } private static void bubbleSort(int[] arr) { for (int i = 1; i \u003c arr.length; i++) { // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j \u003c arr.length - i; j++) { if (arr[j] \u003e arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; } } if (flag) { break; } } } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:1","tags":null,"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"选择排序 选择排序 基本原理： 对于给定的一组记录，经过第一轮比较后得到最小的记录， 然后将该记录与第一个记录的位置进行交换； 接着对不包括第一个记录以外的其他记录进行第二次比较， 得到最小的记录并与第二个记录进行位置交换； 重复该过程，直到进行比较的记录只有一个为止。 /** * @className: SelectSort * @description: 选择排序 * @author: hahaen **/ public class SelectSort { public static void main(String[] args) { int[] arr = {1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22}; SelectSort.selectSort(arr); for (int i : arr) { System.out.print(i + \",\"); } } public static void selectSort(int[] arr) { for (int i = 0; i \u003c arr.length - 1; i++) { int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j \u003c arr.length; j++) { if (arr[j] \u003c arr[min]) { // 记录目前能找到的最小值元素的下标 min = j; } } // 将找到的最小值和i位置所在的值进行交换 if (i != min) { int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; } } } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:2","tags":null,"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"插入排序 插入排序 基本原理： 对于给定的一组数据，初始时假设第一个记录自成一个有序序列， 其余记录为无序序列。接着从第二个记录开始，按照记录的大小依次将当前处理的记录插入到其之前的有序序列中， 直至最后一个记录插入到有序序列中为止。 /** * @className: InsertSort * @description: 插入排序 * @author: hahaen **/ public class InsertSort { public static void main(String[] args) { int[] arr = {1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22}; InsertSort.insertSort(arr); for (int i : arr) { System.out.print(i + \",\"); } } private static void insertSort(int[] arr) { for (int i = 1; i \u003c arr.length; i++) { // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j \u003e 0 \u0026\u0026 tmp \u003c arr[j - 1]) { arr[j] = arr[j - 1]; j--; } // 存在比其小的数，插入 if (j != i) { arr[j] = tmp; } } } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:3","tags":null,"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"希尔排序 希尔排序 基本原理： 先将待排序的数组元素分成多个子序列，使得每个子序列的元素个数相对减少， 然后对各个子序列分别进行直接插入排序，待整个待排序序列\"基本有序后\"， 最后再对所有元素进行一次直接插入排序。 /** * @className: ShellSort * @description: 希尔排序 * @author: hahaen **/ public class ShellSort { public static void main(String[] args) { int[] arr = {1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22}; ShellSort.shellSort(arr); for (int i : arr) { System.out.print(i + \",\"); } } private static void shellSort(int[] arr) { int length = arr.length; int temp; for (int step = length / 2; step \u003e= 1; step /= 2) { for (int i = step; i \u003c length; i++) { temp = arr[i]; int j = i - step; while (j \u003e= 0 \u0026\u0026 arr[j] \u003e temp) { arr[j + step] = arr[j]; j -= step; } arr[j + step] = temp; } } } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:4","tags":null,"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"归并排序 归并排序 基本原理： 利用递归与分治技术将数据序列划分成为越来越小的半子表， 再对半子表排序，最后再用递归方法将排好序的半子表合并成为越来越大的有序序列。 对于给定的一组记录(假设共有n个记录)， 首先将每两个相邻的长度为1的子序列进行归并， 得到n/2(向上取整)个长度为2或1的有序子序列， 再将其两两归并，反复执行此过程，直到得到一个有序序列。 import java.util.Arrays; /** * @className: MergeSort * @description: 归并排序 * @author: hahaen **/ public class MergeSort { public static void main(String[] args) { int[] arr = {1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22}; mergeSort(arr); System.out.println(Arrays.toString(arr)); } public static void mergeSort(int[] arr) { //在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间 int[] temp = new int[arr.length]; sort(arr, 0, arr.length - 1, temp); } private static void sort(int[] arr, int left, int right, int[] temp) { if (left \u003c right) { //左边归并排序，使得左子序列有序 int mid = (left + right) / 2; sort(arr, left, mid, temp); //右边归并排序，使得右子序列有序 sort(arr, mid + 1, right, temp); //将两个有序子数组合并操作 merge(arr, left, mid, right, temp); } } private static void merge(int[] arr, int left, int mid, int right, int[] temp) { //左序列指针 int i = left; //右序列指针 int j = mid + 1; //临时数组指针 int t = 0; while (i \u003c= mid \u0026\u0026 j \u003c= right) { if (arr[i] \u003c= arr[j]) { temp[t++] = arr[i++]; } else { temp[t++] = arr[j++]; } } //将左边剩余元素填充进temp中 while (i \u003c= mid) { temp[t++] = arr[i++]; } //将右序列剩余元素填充进temp中 while (j \u003c= right) { temp[t++] = arr[j++]; } t = 0; //将temp中的元素全部拷贝到原数组中 while (left \u003c= right) { arr[left++] = temp[t++]; } } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:5","tags":null,"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"快速排序 快速排序 基本原理： 对于一组给定的记录，通过一趟排序后，将原序列分为两部分， 其中前一部分的所有记录均比后一部分的所有记录小， 然后再依次对前后两部分的记录进行快速排序， 递归该过程，直到序列中的所有记录均有序为止。 /** * @className: QuickSort * @description: 快速排序 * @author: hahaen **/ public class QuickSort { public static void main(String[] args) { int[] arr = {1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22}; QuickSort.quickSort(arr, 0, arr.length - 1); for (int i : arr) { System.out.print(i + \",\"); } } private static void quickSort(int[] arr, int left, int right) { if (left \u003c right) { int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); } } private static int partition(int[] arr, int left, int right) { // 设定基准值（pivot） int pivot = left; int index = pivot + 1; for (int i = index; i \u003c= right; i++) { if (arr[i] \u003c arr[pivot]) { swap(arr, i, index); index++; } } swap(arr, pivot, index - 1); return index - 1; } private static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:6","tags":null,"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"堆排序 堆排序 基本原理： 对于给定的n个记录，初始时把这些记录看作一颗顺序存储的二叉树， 然后将其调整为一个小顶堆，然后将堆的最后一个元素与堆顶元素进行交换后， 堆的最后一个元素即为最小记录；接着讲前(n-1)个元素重新调整为一个小顶堆， 再将堆顶元素与当前堆的最后一个元素进行交换后得到次小的记录， 重复该过程直到调整的堆中只剩一个元素时为止，该元素即为最大记录， 此时可得到一个有序序列。 /** * @className: HeapSort * @description: 堆排序 * @author: hahaen **/ public class HeapSort { public static void main(String[] args) { int[] arr = {1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22}; HeapSort.heapSort(arr, arr.length); for (int i : arr) { System.out.print(i + \",\"); } } private static void heapSort(int[] arr, int len) { buildMaxHeap(arr, len); for (int i = len - 1; i \u003e 0; i--) { swap(arr, 0, i); len--; heapify(arr, 0, len); } } private static void buildMaxHeap(int[] arr, int len) { for (int i = (int) Math.floor(len / 2); i \u003e= 0; i--) { heapify(arr, i, len); } } private static void heapify(int[] arr, int i, int len) { int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left \u003c len \u0026\u0026 arr[left] \u003e arr[largest]) { largest = left; } if (right \u003c len \u0026\u0026 arr[right] \u003e arr[largest]) { largest = right; } if (largest != i) { swap(arr, i, largest); heapify(arr, largest, len); } } private static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:7","tags":null,"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"计数排序 计数排序 基本原理： 找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 /** * @className: CountingSort * @description: 计数排序 * @author: hahaen **/ public class CountingSort { public static void main(String[] args) { int[] arr = {1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22}; CountingSort.countingSort(arr); for (int i : arr) { System.out.print(i + \",\"); } } private static void countingSort(int[] arr) { int maxValue = getMaxValue(arr); countingSort(arr, maxValue); } private static int[] countingSort(int[] arr, int maxValue) { int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) { bucket[value]++; } int sortedIndex = 0; for (int j = 0; j \u003c bucketLen; j++) { while (bucket[j] \u003e 0) { arr[sortedIndex++] = j; bucket[j]--; } } return arr; } private static int getMaxValue(int[] arr) { int maxValue = arr[0]; for (int value : arr) { if (maxValue \u003c value) { maxValue = value; } } return maxValue; } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:8","tags":null,"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"桶排序 桶排序 基本原理： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 import java.util.Arrays; /** * @className: BucketSort * @description: 桶排序 * @author: hahaen **/ public class BucketSort { public static void main(String[] args) { int[] arr = {1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22}; BucketSort.bucketSort(arr, 5); for (int i : arr) { System.out.print(i + \",\"); } } private static void bucketSort(int[] arr, int bucketSize) { int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) { if (value \u003c minValue) { minValue = value; } else if (value \u003e maxValue) { maxValue = value; } } int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i \u003c arr.length; i++) { int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); } int arrIndex = 0; for (int[] bucket : buckets) { if (bucket.length \u003c= 0) { continue; } // 对每个桶进行排序，这里使用了插入排序 insertSort(bucket); for (int value : bucket) { arr[arrIndex++] = value; } } } private static int[] arrAppend(int[] arr, int value) { arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; } /** * 插入排序 * * @param arr * @return */ private static int[] insertSort(int[] arr) { for (int i = 1; i \u003c arr.length; i++) { // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j \u003e 0 \u0026\u0026 tmp \u003c arr[j - 1]) { arr[j] = arr[j - 1]; j--; } // 存在比其小的数，插入 if (j != i) { arr[j] = tmp; } } return arr; } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:9","tags":null,"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"基数排序 基数排序 基本原理： 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。 由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 import java.util.Arrays; /** * @className: RadixSort * @description: 基数排序 * @author: hahaen **/ public class RadixSort { public static void main(String[] args) { int[] arr = {1, 1, 2, 0, 9, 3, 12, 7, 8, 3, 4, 65, 22}; RadixSort.radixSort(arr); for (int i : arr) { System.out.print(i + \",\"); } } private static void radixSort(int[] arr) { int maxDigit = getMaxDigit(arr); radixSort(arr, maxDigit); } /** * 获取最高位数 * * @param arr * @return */ private static int getMaxDigit(int[] arr) { int maxValue = getMaxValue(arr); return getNumLenght(maxValue); } private static int getMaxValue(int[] arr) { int maxValue = arr[0]; for (int value : arr) { if (maxValue \u003c value) { maxValue = value; } } return maxValue; } protected static int getNumLenght(long num) { if (num == 0) { return 1; } int lenght = 0; for (long temp = num; temp != 0; temp /= 10) { lenght++; } return lenght; } private static int[] radixSort(int[] arr, int maxDigit) { int mod = 10; int dev = 1; for (int i = 0; i \u003c maxDigit; i++, dev *= 10, mod *= 10) { // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; for (int j = 0; j \u003c arr.length; j++) { int bucket = ((arr[j] % mod) / dev) + mod; counter[bucket] = arrayAppend(counter[bucket], arr[j]); } int pos = 0; for (int[] bucket : counter) { for (int value : bucket) { arr[pos++] = value; } } } return arr; } /** * 自动扩容，并保存数据 * * @param arr * @param value * @return */ private static int[] arrayAppend(int[] arr, int value) { arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; } } ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:1:10","tags":null,"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["java知识"],"content":"讲讲广度优先遍历和深度优先遍历？ 广度优先遍历：从上往下对每一层依次访问，在每一层中，从左往右访问结点，访问完一层就进入下一层，直到没有结点可以访问为止。 深度优先遍历：对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次。 ","date":"2022-03-11","objectID":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"Java基础算法","uri":"https://hahaen.github.io/java%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"categories":["MySQL知识"],"content":" left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。 right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。 inner join（内连接）：只返回两个表中连接字段相等的行。 full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。 A表idname1小王2小李3小刘 B表idA_idjob12老师24程序员 左连接：（左边的表不加限制） selecta.name,b.jobfromAaleftjoinBbona.id=b.A_id 返回结果 三条记录小王null小李老师小刘null 右连接：（右边的表不加限制） selecta.name,b.jobfromAarightjoinBbona.id=b.A_id 返回结果 两条记录小李老师null程序员 内连接：（只有2张表匹配的行才能显示） selecta.name,b.jobfromAainnerjoinBbona.id=b.A_id 返回结果 只能得到一条记录小李老师 全外连接：(左右2张表都不加限制） selecta.name,b.jobfromAafulljoinBbona.id=b.A_id 四条数据小王null小李老师小刘nullnull程序员 ","date":"2022-03-11","objectID":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%A6%E8%BF%9E%E6%8E%A5%E5%86%85%E8%BF%9E%E6%8E%A5/:0:0","tags":null,"title":"数据库左连接内连接","uri":"https://hahaen.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%A6%E8%BF%9E%E6%8E%A5%E5%86%85%E8%BF%9E%E6%8E%A5/"},{"categories":["MySQL知识"],"content":"where(条件) select*frompersonwherename='yang'\u0026\u0026age=22; ","date":"2022-03-10","objectID":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:1:0","tags":null,"title":"MySQL数据库关键字","uri":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"like(搜索查询) 搜索查询，或者说模糊匹配，表达式主要涉及到两个符号： 百分号 %：匹配任意多个字符 下划线 _：匹配固定一个字符 例如： 查询所有的数据，找到其中 name 字段以字符「ang」结尾的数据记录集合： select*frompersonwherenamelike'%ang'; 查询所有的数据，找到其中 name 字段以字符「ang」结尾，并且前面还有一个任意字符的数据记录集合： select*frompersonwherenamelike'_ang'; ","date":"2022-03-10","objectID":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:2:0","tags":null,"title":"MySQL数据库关键字","uri":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"in(集合) in 关键字也是使用在 where 子句的条件表达式中，它限制的是一个集合，只要字段的值在集合中即符合条件 例如： 查询出来所有年龄是 22,30,23 的人数据记录 select*frompersonwhereagein(22,30,23); not in 反向限制 ","date":"2022-03-10","objectID":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:3:0","tags":null,"title":"MySQL数据库关键字","uri":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"order by(排列) order by子句根据一列或者多列的值，按照升序或者降序排列数据。 asc表示数据结果集按升序排序，desc表示数据结果集按降序排序。 例子： 数据参照 id 列，倒序排序 select*frompersonorderbyiddesc; ","date":"2022-03-10","objectID":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:4:0","tags":null,"title":"MySQL数据库关键字","uri":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"group by(分组) group by子句用于将查询返回的结果集进行一个分组，并展示各个分组中排在第一个的记录，将分组中其余成员隐藏。 例如： 按照姓名对结果集进行分组,分组之后，只展示每个分组下排序第一的记录，其余成员隐藏。 select*frompersongroupbyname; ","date":"2022-03-10","objectID":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:5:0","tags":null,"title":"MySQL数据库关键字","uri":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"having(排序) having子句在我看来就是一个高配版的where子句，无论是我们的分组或是排序， 都是基于以返回的结果集，也就是说where子句的筛选已经结束。 例如： 对排序、分组后的数据集依然有筛选需求，就用到我们的having子句 selectavg(age)asvagefrompersongroupbynamehavingvage\u003e23; ","date":"2022-03-10","objectID":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:6:0","tags":null,"title":"MySQL数据库关键字","uri":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"between(两个数值之间) 在where中使用between表示一个数在两个数值之间取值 ","date":"2022-03-10","objectID":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:7:0","tags":null,"title":"MySQL数据库关键字","uri":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"distinct(表示将distinct后的属性去重) 去掉重复的关键字 selectdistinct列名from表名-- order by ：排序 -- desc 降序(默认升序) -- asc 升序 select列名from表名orderby列名1desc，列名2asc ","date":"2022-03-10","objectID":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:8:0","tags":null,"title":"MySQL数据库关键字","uri":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"as(别名) ","date":"2022-03-10","objectID":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:9:0","tags":null,"title":"MySQL数据库关键字","uri":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"avg(平均) ","date":"2022-03-10","objectID":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:10:0","tags":null,"title":"MySQL数据库关键字","uri":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"min(最小值) ","date":"2022-03-10","objectID":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:11:0","tags":null,"title":"MySQL数据库关键字","uri":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"max(最大值) ","date":"2022-03-10","objectID":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:12:0","tags":null,"title":"MySQL数据库关键字","uri":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"sum(总和) ","date":"2022-03-10","objectID":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:13:0","tags":null,"title":"MySQL数据库关键字","uri":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["MySQL知识"],"content":"count(计数) ","date":"2022-03-10","objectID":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/:14:0","tags":null,"title":"MySQL数据库关键字","uri":"https://hahaen.github.io/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["JVM"],"content":"JDK=JRE+javac javac 相当于 编译compler jdk java开发工具包,java语言编写的程序所需的开发工具包 jre java运行时环境,即java程序的运行时环境，包含了java虚拟机，java基础类库 jdk包含jre,jre是java运行时环境，另外jdk包含开发时所需要的sdk和编译器javac和javadoc工具 ","date":"2022-03-10","objectID":"https://hahaen.github.io/jdkjre%E5%8C%BA%E5%88%AB/:0:0","tags":null,"title":"JDK、JRE区别","uri":"https://hahaen.github.io/jdkjre%E5%8C%BA%E5%88%AB/"},{"categories":["JVM"],"content":".java — 编译(compler) — 字节码(.class) — JVM .class 打包成 .jar JVM解析字节码 使用文字编辑软件或集成开发环境编辑 Java 源文件，扩展名为 .java 通过编译 .java 文件，生成同名的 .class 字节码文件 通过 JVM 解释方式，将 .class 字节码文件转变为由 0 或 1 组成的二进制指令（机器码）运行 ","date":"2022-03-10","objectID":"https://hahaen.github.io/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/:0:0","tags":null,"title":"Java程序的运行原理","uri":"https://hahaen.github.io/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"},{"categories":["maven"],"content":"生命周期(lifecycle) default生命周期处理项目部署 clean生命周期处理项目清理 site生命周期处理项目站点文档的创建 ","date":"2021-11-21","objectID":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/:1:0","tags":null,"title":"Maven构建","uri":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/"},{"categories":["maven"],"content":"阶段(phase) 每个构建生命周期都由不同的构建阶段列表定义，其中构建阶段表示生命周期中的一个阶段。 例如，default生命周期包括以下阶段： validate - 验证项目是否正确，并提供所有必要的信息 compile - 编译项目源代码 test - 使用合适的单元测试框架测试编译后的源代码。这些测试不需要打包或部署代码 package - 将编译后的代码以其可分发的格式打包，例如JAR verify - 对集成测试的结果进行检查，以确保满足质量标准 install -将包安装到本地存储库中，作为本地其他项目中的依赖项使用 deploy - 在集成或发布环境中操作，将最终包复制到远程存储库，以便与其他开发人员和项目共享 这些生命周期阶段(加上这里没有显示的其他生命周期阶段)按顺序执行，以完成default生命周期。 鉴于上面的生命周期阶段，这意味着当使用default生命周期时。 Maven将首先验证项目，然后将视图编译源代码， 运行测试，打包二进制文件(如jar)， 运行集成测试方案，验证集成测试， 安装验证过的包到本地存储库，然后将安装包部署到远程存储库。 ","date":"2021-11-21","objectID":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/:2:0","tags":null,"title":"Maven构建","uri":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/"},{"categories":["maven"],"content":"插件(plugin)的目标(goal) Maven的操作是基于不同的插件的不同目标来实现的 例 mvn clean 使用的参数是clean阶段，而实际执行的是maven-clean-plugin插件的clean目标。 常用的插件 插件 maven-clean-plugin maven-resouces-plugin maven-compiler-plugin maven-deploy-plugin maven-surefire-plugin maven-install-plugin 直接运行插件 可使用插件名:目标名的参数形式直接运行某插件的某目标。 例如： mvn dependency:copy-dependencies 以上命令执行了dependency插件的copy-dependencies目标。 阶段(phase)和插件目标(goal)可以同时使用 例如： mvn clean dependency:copy-dependencies package 执行了clean周期的pre-clean和clean阶段， dependency插件的copy-dependencies目标， default周期package阶段及package之前的所有阶段。 ","date":"2021-11-21","objectID":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/:3:0","tags":null,"title":"Maven构建","uri":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/"},{"categories":["maven"],"content":"绑定的整个工作原理 官方文档 groupId：组织标识名（简单理解成 包名） artifactId：项目名称 version：项目的当前版本 packaging：项目的打包方式，最为常见的jar和war两种（项目中继承的话，为pom） classifier: 该元素用来帮助定义构建输出的一些附属构件（不能被直接定义） 依赖性管理，在pom.xml文件中\u003cdependency\u003e\u003c/dependency\u003e中 ","date":"2021-11-21","objectID":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/:4:0","tags":null,"title":"Maven构建","uri":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/"},{"categories":["maven"],"content":"依赖传递 若A依赖B，B依赖C，则A也依赖于C（A对于C为间接依赖） ","date":"2021-11-21","objectID":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/:4:1","tags":null,"title":"Maven构建","uri":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/"},{"categories":["maven"],"content":"仓库管理 仓库用来统一存储所有Maven共享构建的位置， 根据maven坐标，目录方式：groupId/artifactId/version/artifactId-version.packaging 就可以唯一确定一个构建。 每个用户只有一个本地仓库，默认是在${user.home}/.m2/repository/，${user.home}代表的是用户目录 Maven默认的远程仓库：URL：http://search.maven.org/，我们需要引用外部的包时，可以从上面查到相关的GroupId、版本号等信息 私服：是一种特殊的远程仓库，架设在局域网内的仓库（一般公司内部都会有一个自己的私服） ","date":"2021-11-21","objectID":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/:4:2","tags":null,"title":"Maven构建","uri":"https://hahaen.github.io/maven%E6%9E%84%E5%BB%BA/"},{"categories":["各种问题"],"content":"题目地址 ","date":"2021-11-09","objectID":"https://hahaen.github.io/docker%E6%8C%82%E8%BD%BD%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:0:0","tags":null,"title":"Docker挂载问题解决","uri":"https://hahaen.github.io/docker%E6%8C%82%E8%BD%BD%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["各种问题"],"content":"docker desktop win10挂载问题解决 系统：win10 docker pull blindpirate/hcsp-quiz 尝试自己编写一个docker run命令，完成以下要求： 使用交互式命令行模式(-it)启动Docker容器。 向启动的Docker容器内挂载一个文件（卷），使得容器内能够读取到/app/config.txt文件，其内容为字符串\"ABC\"。 向启动的Docker容器内传递一个环境变量HCSP_ENV=DEF。 为启动的Docker容器设置要执行的命令：java Main。 如果一切正确，命令行会输出： 答案是: XXXXX The answer is: XXXXXXX 提示未winpty docker run -e HCSP_ENV=DEF -itv //e/xiedaimala/practise-docker-run/config.txt:/app/config.txt blindpirate/hcsp-quiz 未挂载 winpty docker run -e HCSP_ENV=DEF -itv /e/xiedaimala/practise-docker-run/config.txt:/app/config.txt blindpirate/hcsp-quiz 成功 winpty docker run -e HCSP_ENV=DEF -itv //e/xiedaimala/practise-docker-run/config.txt:/app/config.txt blindpirate/hcsp-quiz ","date":"2021-11-09","objectID":"https://hahaen.github.io/docker%E6%8C%82%E8%BD%BD%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:1:0","tags":null,"title":"Docker挂载问题解决","uri":"https://hahaen.github.io/docker%E6%8C%82%E8%BD%BD%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["各种问题"],"content":"idea版本2021.2.1 ","date":"2021-11-02","objectID":"https://hahaen.github.io/idea%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:0:0","tags":null,"title":"Idea个人使用问题解决办法","uri":"https://hahaen.github.io/idea%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["各种问题"],"content":"连接mysql报错 删除这三个就测试成功 ","date":"2021-11-02","objectID":"https://hahaen.github.io/idea%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:1:0","tags":null,"title":"Idea个人使用问题解决办法","uri":"https://hahaen.github.io/idea%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["工具教程"],"content":"例： docker run --name mymysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql:5.7.27 \r docker run --name=mediawiki_mysql \\ -e MYSQL_DATABASE=wikidb \\ -e MYSQL_USER=wikiuser \\ -e MYSQL_PASSWORD=mysecret \\ -e MYSQL_ROOT_PASSWORD=zhang123 \\ -v /var/mediawiki/mysql:/var/lib/mysql \\ -d mysql:5.7.27 上面命令中的 \\ 是换行 -d 是指定镜像，本地没有的话会从docker服务器下载 -p 映射容器的3306到本地3306，前面是本地端口，-p 3306:3306 这里已经设置了一组管理数据库的用户名:wikiuser 密码:mysecret 通常使用-e MYSQL_RANDOM_ROOT_PASSWORD=1 把root设置为随机，只使用wikiuser用户来管理 -v 是映射本地目录到容器，目录需要提前创建，或者sudo chmod 777 /var/mediawiki，启动容器会自己创建mysql目录 \r进入容器：\rdocker exec -it [容器名或容器ID] bash ","date":"2021-11-02","objectID":"https://hahaen.github.io/mysql-docker%E7%89%88%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"Mysql Docker版教程","uri":"https://hahaen.github.io/mysql-docker%E7%89%88%E6%95%99%E7%A8%8B/"},{"categories":["java知识"],"content":"正则表达式在线测试 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:0","tags":null,"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java知识"],"content":"基本用法 常用的元字符 ^ 开始位置 $ 结束位置 . 单个任意字符（不⼀一定包含换⾏行行符 \\w 单个“word”字符字母/数字/下划线/汉字 \\s 单个空白字符（\\n\\r\\t） \\d 单个数字字符 \\b 单词的开始或结束 重复 * 0次或多次 + 1次或多次 ？ 0次或1次 {n} n次 {n,} \u003e=n次 {n,m} n到m次 选择 [aeiou] 单个的a/e/i/o/u字符之⼀一 [0-9] 单个数字字符 [A-Z] 单个大写字母 [A-Z0-9] 大写字母或者数字或者下划线 Hi|hi 等价于 [Hh]i Hi或者hi 反义 [^aeiou] 单个的除a/e/i/o/u之外的字符 [^A] 单个非x字符 \\W 单个非\\w（字⺟母/数字/下划线/汉字） \\S 单个非\\s（空白) \\D 单个非\\d（数字）字符 \\B 非开头/结束位置 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:1","tags":null,"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java知识"],"content":"Java中的正则表达式 String split() replaceAll/replaceFirst matches 效率低 尽量少用、少编译 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:2","tags":null,"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java知识"],"content":"分组与捕获 左括号( –开始数 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:3","tags":null,"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["java知识"],"content":"Java中处理捕获 ","date":"2021-11-02","objectID":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:4","tags":null,"title":"正则表达式","uri":"https://hahaen.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["前端"],"content":"URL 英文：Uniform Resource Locator https://zh.wikipedia.org:443/w/index.php?title=随机页面 https，是协议； zh.wikipedia.org，是服务器； 443，是服务器上的网络端口号； /w/index.php，是路径； ?title=Special:随机页面，是询问。 \r ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:1:0","tags":null,"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["前端"],"content":"DNS 英文：Domain Name System ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:2:0","tags":null,"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["前端"],"content":"作用： 根据域名查出IP地址 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:2:1","tags":null,"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["前端"],"content":"nslookup 命令 用于互动式地查询域名记录 进入交互模式，总共有两种方法。 第一种方法，直接输入 nslookup 命令，不加任何参数，则直接进入交互模式，此时 nslookup 会连接到默认的域名服务器（即 /etc/resolv.conf 的第一个 dns 地址）。 第二种方法，是支持选定不同域名服务器的。需要设置第一个参数为“-”，然后第二个参数是设置要连接的域名服务器主机名或 IP 地址。 如果你直接在 nslookup 命令后加上所要查询的 IP 或主机名，那么就进入了非交互模式。当然，也可以在第二个参数位置设置所要连接的域名服务器。 例子 交互模式下查询域名 nslookup \u003e www.douban.com Server: 127.0.1.1 // 往上连接的 DNS 服务器 Address: 127.0.1.1#53 // DNS 服务器 IP 地址与端口 Non-authoritative answer: // 非权威答案，从上连 DNS 服务器本地缓存中读取，非实际查询得到 Name: www.douban.com Address: 115.182.201.6 // IP 地址 Name: www.douban.com Address: 115.182.201.7 Name: www.douban.com Address: 115.182.201.8 交互模式下更改 DNS 进入交互模式之后，使用 server dns-server 来改变上连 DNS 服务器地址 查询域名 ip 地址 nslookup www.douban.com [dns-server] //如果没有指定 dns-server，使用系统默认的 DNS 服务器。 \r","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:2:2","tags":null,"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["前端"],"content":"IP ip138-查询本机ip ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:3:0","tags":null,"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["前端"],"content":"IP地址： 互联网协议地址 IP地址是人们在Internet上为了区分数以亿计的主机而给每台主机分配的一个专门的地址，通过IP地址就可以访问到每一台主机。 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:3:1","tags":null,"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["前端"],"content":"ping 命令 Ping 命令详解 输入ping /? ，列出ping的相关参数 用法: ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS] [-r count] [-s count] [[-j host-list] | [-k host-list]] [-w timeout] [-R] [-S srcaddr] [-c compartment] [-p] [-4] [-6] target_name -t ：Ping 指定的计算机直到中断。 -a ：将地址解析为计算机名。 -n count ：发送 count 指定的 ECHO 数据包数。默认值为 4。 -l size ：发送包含由 size 指定的数据量的 ECHO 数据包。默认为 32 字节；最大值是65,527。 -f ：在数据包中发送\"不要分段\"标志。数据包就不会被路由上的网关分段。 -i ttl :将\"生存时间\"字段设置为 ttl 指定的值。 -v tos :将\"服务类型\"字段设置为 tos 指定的值。 -r count :在\"记录路由\"字段中记录传出和返回数据包的路由。count 可以指定最少 1 台，最多 9 台计算机。 -s count :指定 count 指定的跃点数的时间戳。 -j host-list :利用 host-list 指定的计算机列表路由数据包。连续计算机可以被中间网关分隔（路由稀疏源）IP 允许的最大数量为 9。 -k host-list :利用 host-list 指定的计算机列表路由数据包。连续计算机不能被中间网关分隔（路由严格源）IP 允许的最大数量为 9。 -w timeout :指定超时间隔，单位为毫秒。 destination-list :指定要 ping 的远程计算机。 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:3:2","tags":null,"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["前端"],"content":"域名 域名-维基百科 域名是由一串用点分隔的字符组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。 www.xiedaimala.com和xiedaimala.com 不是同一域名 com是顶级域名 xiedaimala.com是二级域名(俗称一级域名) www.xiedaimala.com是三级域名(俗称二级) 上面的两是父子关系 例如 github. io把子域名 XXX.github.io免费给你使用 所以www.xiedaimala.com和xiedaimala. com可以不是同一家公司,也可以是 www是多余的,非常多余。 ","date":"2021-10-29","objectID":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/:4:0","tags":null,"title":"浅析URL","uri":"https://hahaen.github.io/%E6%B5%85%E6%9E%90url/"},{"categories":["前端"],"content":"搜索技巧： 谷歌搜索 mdn + xx(标签) ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:1:0","tags":null,"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"a 标签的用法 ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:0","tags":null,"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"href \u003cul\u003e \u003cli\u003e\u003ca href=\"http://baidu.com\"\u003e百度\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"https://baidu.com\"\u003e百度\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"//baidu.com\"\u003e百度\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/a/b/index.html\"\u003e/a/b/index.html页面\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"./index.html\"\u003eindex.html页面\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"123456789@163.com\"\u003eEmail\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"123456789\"\u003ePhone\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e 注意: 可以使用 href=\"#top\" 或者 href=\"#\" 链接返回到页面顶部。 \r","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:1","tags":null,"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"target _self: 当前页面加载。此值是默认的，如果没有指定属性的话。 _blank: 新窗口打开。 _parent: 加载响应到当前的浏览上下文的父浏览上下文。如果没有parent框架或者浏览上下文，此选项的行为方式与 _self 相同。 _top: IHTML4中：加载的响应成完整的，原来的窗口，取消所有其它frame。 HTML5中：加载响应进入顶层浏览上下文（即，浏览上下文，它是当前的一个的祖先，并且没有parent）。如果没有parent框架或者浏览上下文，此选项的行为方式相同_self \r ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:2","tags":null,"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"作用 跳转外部页面 跳转内部锚点 跳转到邮箱或电话等 a ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:3","tags":null,"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"img 标签的用法 \u003cimg class=\"fit-picture\" src=\"1.jpg\" alt=\"网络错误\"\u003e src 属性是必须的，它包含了你想嵌入的图片的文件路径。 alt 属性包含一条对图像的文本描述，这不是强制性的。如果由于某种原因无法加载图像，普通浏览器也会在页面上显示alt 属性中的备用文本：例如，网络错误、内容被屏蔽或链接过期时。 img ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:3:0","tags":null,"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"table 标签的用法 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth colspan=\"2\"\u003eThe table header\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003eThe table body\u003c/td\u003e \u003ctd\u003ewith two columns\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e table ","date":"2021-10-28","objectID":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:0","tags":null,"title":"HTML常用标签","uri":"https://hahaen.github.io/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["java知识"],"content":"你知道java中有几种方式实现一个线程？ 实现一个线程的话有三种方法，首先前面两种的话是比较常用的， 我们首先第一种，我们可以去实现我们的线程（Thread）类，然后第二种是实现我们的Runnable接口，那这两种方式的话，都是去重写我们的run方法， 然后还有我们的第三种，我们可以去实现我们的Callable一个接口，那这里面需要我们去实现的是一个call()方法，就这些。 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:1:0","tags":null,"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"创建线程池的方法 通过ThreadPoolExecutor类自定义 好处:避免使用重复的线程来创建线程产生的额外的开销。 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:2:0","tags":null,"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"线程池的七大参数 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:3:0","tags":null,"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"那线程池有用过吗？知道他有什么作用吗？ 线程池的话是为了解决我们这个突然爆发的一个线程，去大量爆发的线程去设计的嘛， 他是通过几个有限的一个、几个固定的线程，去给我们的一个大量的操作去服务的，他主要是要去减少我们的创建和销毁线程去需要的时间， 就是我们要提高我们的效率嘛，那我在项目里面用的过程中， 其实我是感觉说如果一个线程所需要执行的时间非常长的话，其实没有必要用这个线程池的。 因为我觉得这个并不是说线程池他不能长时间去操作，而是我感觉不适合嘛，因为我们本来要降低这个线程创建的销毁， 结果这个线程呢，他如果时间很久的话还不好控制，所以还不如直接去创建线程，因为我们是不能直接控制线程池里面的线程的开始啊挂起啊终止啊这些状态的嘛。 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:4:0","tags":null,"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"Java多线程 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:5:0","tags":null,"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"多线程带来了什么问题，如何避免？ 线程安全问题 例如：银行存钱取件需要完整，不可出现错误。 保证线程安全需要满足两大条件： 原子性：一系列操作，要么全部完成，要么全部不完成，不可被分割，不会结束在中间某个环节。 可见性：当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。 上下文切换 线程与 CPU 单核执行是一对一的 CPU 是通过时间片算法来执行任务的，不同的线程活跃状态不同，CPU 会在多个线程间切换执行， 在切换时会保存上一个任务的状态，以便下次切换回这个任务时可以再加载到这个任务的状态 线程数越多，带来的上下文切换越严重，上下文切换会带来 CPU 系统态使用率占用 这就是当我们开启大量线程，系统反而更慢 解决办法 减少锁等待 使用合适的线程数 CAS 算法 死锁 就是比如说，我们有两个或者两个以上的这个进程或者线程，都在等待对方释放资源的话，那其实没有一方提起这个释放资源的操作的话呢，就从而造成了一种阻塞的现象， 这个称之为死锁。结果就是说我们两个进程或者两个线程他们都会陷入到一个无限等待中， 我也可以简单的说一下，就是，就是面试官您给我说，如果我回答上这个问题的话，你就给我这个offer， 那如果玩说如果你给我这个offer的话，我就回答您这个问题，那咱俩都在等待对方释放这个锁嘛，那这样就造成了一个死锁问题，就是这样的。 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:5:1","tags":null,"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["java知识"],"content":"java中如何保证线程安全 ","date":"2021-09-28","objectID":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/:6:0","tags":null,"title":"Java多线程原理","uri":"https://hahaen.github.io/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/"},{"categories":["前端"],"content":"Http方法与状态码 http方法 GET 拿 POST 发送 GET / HTTP/1.1 //GET请求根路径 使用HTTP1.1协议 Host: xiedaimala.com User-Agent: //用户代理（浏览器） 可根据查看相关信息 Http状态码 200请求成功。一般用于GET与POST请求 http猫 ","date":"2021-09-13","objectID":"https://hahaen.github.io/http%E7%9A%84%E5%9F%BA%E7%A1%80/:1:0","tags":null,"title":"HTTP的基础","uri":"https://hahaen.github.io/http%E7%9A%84%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"HTTP的header与body 重要的header Accept Cookie User-Agent //浏览器标识 Referer //上一个页面是什么 Referer: http://idpeng.xyz/ Content-type //下载或者图片 content-type: text/html; charset=utf-8 Set-Cookie //登录后服务器自动设置的cookie http是无状态的 ","date":"2021-09-13","objectID":"https://hahaen.github.io/http%E7%9A%84%E5%9F%BA%E7%A1%80/:2:0","tags":null,"title":"HTTP的基础","uri":"https://hahaen.github.io/http%E7%9A%84%E5%9F%BA%E7%A1%80/"},{"categories":["网络"],"content":"计算机网络是如何工作的 在打开网页的时候发生了什么 主机 域名与DNS 端⼝:HTTPS协议的默认端⼝口是443，HTTP协议的默认端⼝口是80 TCP协议 HTTP协议 ","date":"2021-09-11","objectID":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:1:0","tags":null,"title":"JavaWeb前后端架构分析","uri":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["网络"],"content":"浏览器是如何工作的 在网络上传输的只是字节流 HTTP协议 HTML JavaScript CSS ","date":"2021-09-11","objectID":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:2:0","tags":null,"title":"JavaWeb前后端架构分析","uri":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["网络"],"content":"同步与异步加载 同步加载：同步模式，又称阻塞模式，会阻止浏览器的后续处理，停止了后续的解析，因此停止了后续的文件加载（如图像）、渲染、代码执行。 异步加载：异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理。 服务器端一次返回所有的数据 服务器端返回部分数据，使用AJAX异步加载 区别 异步：在异步模式下，当我们使用AJAX发送完请求后，可能还有代码需要执行。这个时候可能由于种种原因导致服务器还没有响应我们的请求，但是因为我们采用了异步执行方式，所有包含AJAX请求代码的函数中的剩余代码将继续执行。如果我们是将请求结果交由另外一个JS函数去处理的，那么，这个时候就好比两条线程同时执行一样。 同步：在同步模式下，当我们使用AJAX发送完请求后，后续还有代码需要执行，我们同样将服务器响应交由另一个JS函数去处理，但是这时的代码执行情况是：在服务器没有响应或者处理响应结果的JS函数还没有处理完成return时，包含请求代码的函数的剩余代码是不能够执行的。就好比单线程一样，请求发出后就进入阻塞状态，知道接触阻塞余下的代码才会继续执行。 ","date":"2021-09-11","objectID":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:3:0","tags":null,"title":"JavaWeb前后端架构分析","uri":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["网络"],"content":"注意 只要浏览器能做到的 其他代码一定能做到 ","date":"2021-09-11","objectID":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/:4:0","tags":null,"title":"JavaWeb前后端架构分析","uri":"https://hahaen.github.io/javaweb%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["maven"],"content":"jar jar是将很多类文件打包后的一个压缩包,导入 jar 后,可以直接使用里面的类或调用其中的功能。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:1:0","tags":null,"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["maven"],"content":"java包的原理 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:2:0","tags":null,"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["maven"],"content":"传递性依赖 我们依赖的包还依赖了别的类，这种依赖是具有传递性的。 传递性依赖带来的最大的问题就是： 我们在 -classpath 后会添加项目依赖的各种各样的 jar 包； 如果两个仅仅不同版本的 jar 包被同时写进了 -classpath 参数里面； JVM 在 classpath 中寻找类文件的顺序是从前找到后的，也就是说如果有两个仅仅不同版本的 jar ：demo-1.0.jar 和 demo-2.0.jar ，哪个放在前面哪个就会被使用。 如果 demo-1.0.jar 的顺序在 demo-2.0.jar 之前，就会使用demo-1.0.jar加载的类文件，这样的话高版本的jar就会不生效。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:2:1","tags":null,"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["maven"],"content":"maven包的管理 Maven 是一个项目管理工具它包含： 一个项目对象模型 一组标准集合 一个项目生命周期 一个依赖管理系统 用来运行定义在生命周期阶段中插件目标的逻辑 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:3:0","tags":null,"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["maven"],"content":"maven怎么进行管理 Maven 包管理的做法是：Convention over configuration（约定优于配置原则），体现在 POM。 POM是 Maven 工程的基本工作单元，是一个 XML 文件。 该文件中包含了项目的基本信息，用于描述项目如何构建，声明项目依赖等等。 pom.xml \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ehcsp\u003c/groupId\u003e \u003cartifactId\u003efix-bug-in-integer-equals\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e1.8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e1.8\u003c/maven.compiler.target\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003c/properties\u003e \u003cprofiles\u003e \u003cprofile\u003e \u003cid\u003ealiyunMavenMirror\u003c/id\u003e \u003cactivation\u003e \u003cactiveByDefault\u003etrue\u003c/activeByDefault\u003e \u003c/activation\u003e \u003cpluginRepositories\u003e \u003cpluginRepository\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003c/pluginRepository\u003e \u003c/pluginRepositories\u003e \u003crepositories\u003e \u003crepository\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e \u003c/profile\u003e \u003cprofile\u003e \u003cid\u003emavenCentral\u003c/id\u003e \u003cpluginRepositories\u003e \u003cpluginRepository\u003e \u003cid\u003emavenCentral\u003c/id\u003e \u003cname\u003emavenCentral\u003c/name\u003e \u003curl\u003ehttps://repo.maven.apache.org/maven2\u003c/url\u003e \u003c/pluginRepository\u003e \u003c/pluginRepositories\u003e \u003crepositories\u003e \u003crepository\u003e \u003cid\u003emavenCentral\u003c/id\u003e \u003cname\u003emavenCentral\u003c/name\u003e \u003curl\u003ehttps://repo.maven.apache.org/maven2\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e \u003c/profile\u003e \u003c/profiles\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003cversion\u003e2.22.1\u003c/version\u003e \u003cconfiguration\u003e \u003cargLine\u003e-Dfile.encoding=UTF-8\u003c/argLine\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003c/project\u003e 引入第三方包 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.6.0\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 里面加入了junit-jupiter-engine的jar 如果在本地仓库没有找到对应的 jar 包，Maven 就会从远程的中央仓库进行下载，然后放到本地仓库中。 Maven 中央仓库位置 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:3:1","tags":null,"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["maven"],"content":"包冲突及解决办法 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:4:0","tags":null,"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["maven"],"content":"包冲突 相比于C1来说，C2这个第三方包离项目更接近，因此Maven会自动帮你把C1去除，而保留C2。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:4:1","tags":null,"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["maven"],"content":"解决冲突的办法 直接依赖C2 排除C1 通过Maven helper插件来解决包冲突问题 排除 \u003cdependency\u003e \u003cgroupId\u003exxx\u003c/groupId\u003e \u003cartifactId\u003exxx\u003c/artifactId\u003e \u003cversion\u003e1.0.0\u003c/version\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eyyy\u003c/groupId\u003e \u003cartifactId\u003eyyy\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e 排除了xxx依赖中的后代yyy依赖，也可以解决包冲突的问题 ","date":"2021-09-09","objectID":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/:4:2","tags":null,"title":"Maven与包","uri":"https://hahaen.github.io/maven%E4%B8%8E%E5%8C%85/"},{"categories":["工具教程"],"content":"git系列操作 ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:0:0","tags":null,"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["工具教程"],"content":"git六行配置 git config --global user.name 你的英文名 git config --global user.email 你的邮箱 git config --global push.default simple git config --global core.quotepath false git config --global core.editor \"code --wait\" git config --global core.autocrlf input 注意： 上面的英文名和邮箱跟 GitHub 没有关系。 可以跟 GitHub 的用户名和邮箱保持一致，也可以不一致。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:1:0","tags":null,"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["工具教程"],"content":"新建代码库 # 在当前目录新建一个 Git 代码库 git init # 新建一个目录，将其初始化为 Git 代码库 git init [project-name] # 下载一个项目和它的整个代码历史 git clone [url] ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:2:0","tags":null,"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["工具教程"],"content":"配置文件 # 显示当前的 Git 配置 git config --list # 编辑 Git 配置文件 git config -e [--global] ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:3:0","tags":null,"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["工具教程"],"content":"增加/删除文件 # 添加指定文件到暂存区 git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 git add [dir] # 添加当前目录的所有文件到暂存区 git add . # 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] 代码提交 # 提交暂存区到仓库区 git commit -m [message] # 提交暂存区的指定文件到仓库区 git commit [file1] [file2] ... -m [message] # 提交工作区自上次 commit 之后的变化，直接到仓库区 git commit -a # 提交时显示所有 diff 信息(推荐) git commit -v # 使用一次新的 commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息 git commit --amend -m [message] # 重做上一次 commit，并包括指定文件的新变化 git commit --amend ... ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:4:0","tags":null,"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["工具教程"],"content":"分支 # 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 列出所有本地分支和远程分支 git branch -a # 新建一个分支，但依然停留在当前分支 git branch [branch-name] # 新建一个分支，并切换到该分支 git checkout -b [branch] # 新建一个分支，指向指定 commit git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 git checkout [branch-name] # 建立追踪关系，在现有分支与指定的远程分支之间 git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 git merge [branch] # 选择一个 commit，合并进当前分支 git cherry-pick [commit] # 删除分支 git branch -d [branch-name] # 删除远程分支 git push origin --delete git branch -dr ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:5:0","tags":null,"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["工具教程"],"content":"提交代码 git pull 提交代码到远程仓库 git push -u origin master 提交本地指定分支master代码到远程仓库 ","date":"2021-09-09","objectID":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/:6:0","tags":null,"title":"Git本地仓库与远程仓库","uri":"https://hahaen.github.io/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"categories":["运维"],"content":"ls命令 list 的缩写,可以查看文件权限(包括目录、文件夹、文件权限),查看目录信息。 ls -a 列出目录所有文件，包含以.开始的隐藏文件 ls -A 列出除.及..的其它文件 ls -r 反序排列 ls -t 以文件修改时间排序 ls -S 以文件大小排序 ls -h 以易读大小显示 ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":null,"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["运维"],"content":"cd命令 cd [目录名] 进入目录 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":null,"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["运维"],"content":"pwd命令 pwd 查看当前路径 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":null,"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["运维"],"content":"mkdik命令 mkdir t 在当前工作目录下创建名为 t的文件夹 mkdir -p /tmp/test/t1/t 在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:0","tags":null,"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["运维"],"content":"rm命令 rm -i *.log 删除任何 .log 文件，删除前逐一询问确认 rm -rf test 删除 test 子目录及子目录中所有档案删除，并且不用一一确认 rm -- -f* 删除以 -f 开头的文件 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:5:0","tags":null,"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["运维"],"content":"mv命令 mv test.log test1.txt 将文件 test.log 重命名为 test1.txt mv llog1.txt log2.txt log3.txt /test3 将文件 log1.txt,log2.txt,log3.txt 移动到根的 test3 目录中 mv -i log1.txt log2.txt 将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖 mv * ../ 移动当前文件夹下的所有文件到上一级目录 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:6:0","tags":null,"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["运维"],"content":"cp命令 -i 提示 -r 复制目录及目录内所有项目 -a 复制的文件与原文件时间一样 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:7:0","tags":null,"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["运维"],"content":"cat命令-查看文件内容 cat filename 一次显示整个文件 cat \u003e filename 从键盘创建一个文件 cat file1 file2 \u003e file 将几个文件合并为一个文件 sed -n \"10p\" move.sh # 显示第10行 sed -n \"7,10p\" move.sh # 显示第7行到第10行 cat recorde | head -n 10|tail -n 1 # 显示第10行，先显示前10行，再显示这10行中的最后一行 cat recorde | tail -n +10 | head -n 1 # 显示第10行；先显示第10行及以后的内容，再显示这里的第一行 tail -n 100 #显示最后100行 tail -n +1000 # 从1000行开始显示，显示1000行以后所有行 head -n 1000 # 显示前面1000行 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:8:0","tags":null,"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["运维"],"content":"chmod 赋予权限 chmod 644 mm.txt 即设定文件mm.txt的属性为：-rw-r--r-- r(Read，读取，权限值为4)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目 录的权限。 w(Write,写入，权限值为2)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。 x(eXecute，执行，权限值为1)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。 rwx rw- r– 764 rw- r– r– 644 rw- rw- r– 664 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:9:0","tags":null,"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["运维"],"content":"more 命令 功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:10:0","tags":null,"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["运维"],"content":"命令参数： +n 从笫 n 行开始显示 -n 定义屏幕大小为n行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:10:1","tags":null,"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["运维"],"content":"常用操作命令 Enter 向下 n 行，需要定义。默认为 1 行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 :f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:10:2","tags":null,"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["运维"],"content":"which 命令 which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 ","date":"2021-09-09","objectID":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:11:0","tags":null,"title":"Linux常用命令行","uri":"https://hahaen.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"免责声明 此文件夹下所有资料供本人学习 您如下载，必须从计算机或手机中完全删除以上内容，且与本人毫无关系 如有侵权，请联系删除 谢谢 ","date":"0001-01-01","objectID":"https://hahaen.github.io/study/study%E8%AF%B4%E6%98%8E/:0:0","tags":null,"title":"","uri":"https://hahaen.github.io/study/study%E8%AF%B4%E6%98%8E/"}]